/*
 *  Copyright (C) 2013, DECOIT GmbH
 *
 *	This file is part of VISA Topology-Editor.
 *
 *	VISA Topology-Editor is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by the
 *	Free Software Foundation, either version 3 of the License, or (at your option)
 *	any later version.
 *
 *	VISA Topology-Editor is distributed in the hope that it will be useful, but
 *	WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *	or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 *	more details.
 *
 *	You should have received a copy of the GNU General Public License along with
 *	VISA Topology-Editor. If not, see <http://www.gnu.org/licenses/>.
 */
 
// jsLint directives
/*jslint debug: true, plusplus: true, white: true, browser: true, devel: true */
/*global $, PathFinder */

// TODO remove console.log calls!
// TODO handle IO-Tool busy responses in all IO-Tool AJAX requests
// TODO replace alert() calls with alertDialog() calls

/**
 * VISA closure for topology editor components
 *
 * @author Thomas Rix
 * @version alpha2
 */
var VISA = (function() {
	/* Enable strict mode */
	"use strict";

	// Declare attributes
	var	topologyStorage,				// Storage for the topology that existed in the backend when the editor was launched, will be filled by AJAX request to backend
		vsaTemplates,
		tblRowCount,					// Store the number of rows in the editor grid
		tblCellCount,					// Store the number of cells in a row in the editor grid
		cellSize,						// Size of a grid cell in pixels, cells are squares
		componentMargin,				// Number of rings around a component which will be marked as obstacles
		subGridDialogDummy,				// Template for sub grid dialogs
		customLanguage,					// Custom language chosen by the user is stored here
		dragLocks,						// Count how many options want the drag function to be disabled
		localizeData,					// The object with the localization data is stored here to localize several special objects
		optPathFinderEnable,			// Option to enable (true) or disable (false) pathfinding
		optExportDownloadLink,			// Store the link to the exported RDF/XML file
		optExportTopoExported,			// Mark if the current topology was exported or not
		optExportDownloadCurrTopo,		// Mark if the currently exported topology matches the currently shown topology
		subgridDialogs = {},
		activeSubgrid = null,
		activeIOTopology = null,
		activeVSATemplate = null,
		vlanIfCount = {},
		componentContextMenu,
		groupContextMenu,
		createCompDialog,				// Dialog for component creation
		createVSADialog,
		cableDialog,					// Dialog for cable details and remove action
		topologyDialog,
		networkDialog,
		iotoolDialog,
		rdfDialog,						// Dialog for RDF/XML import/export actions
		resetDialog,					// Dialog for topology reset confirmation
		componentDialog,
		vlanAssignDialog,
		consoleDialog,
		iotoolBlockUI,
		ifOrientationSelect,
		networkSelect,
		cableStart = null,				// Starting point of a cable
		cableEnd = null,				// Ending point of a cable
		cableCorners = [],				// Storage for the corners of a cable, generated by pathfinder or by manually creating a cable
		topologyCables = {},			// All drawn cables are stored in this structure: topologyCables[cableID][start/end/path/isVirtual]
		cablePortMap = {},				// Map a cable to a secific port: cablePortMap[portID] = cableID
		nextVirtCableID = 0,
		lastCell = null,				// Last cell the mouse curser hovered, needed in mousemove handlers
		tmpPathCells,					// Cells carrying the class tmpPath
		newPathCells,					// Cells carrying the class newPath
		documentRoot,
		uploaderInit = false;

	/**
	 * Initialize the VISA script components
	 *
	 * @param {Integer} editorRows Number of rows for the editor grid
 	 * @param {Integer} editorCols Number of columns for the editor grid
	 * @param {Integer} cSize Size of a grid cell in pixels (cells are squares)
	 * @param {Integer} compMargin Number of obstacle rings around each component
	 * @memberOf VISA
	 */
	function init(editorRows, editorCols, cSize, compMargin) {
		var gridHTML = "",	// HTML code for the editorgrid
			response,
			i,				// for-loop counter, rows
			j;				// for-loop counter, cols

		// Store editor grid dimensions
		tblRowCount = editorRows;
		tblCellCount = editorCols;
		cellSize = cSize;
		componentMargin = compMargin;
		dragLocks = 0;
		tmpPathCells = $();
		newPathCells = $();

		//consoleDialog = $("#consoleDialog").dialog({
		//	autoOpen: false,
		//	closeOnEscape: true,
		//	draggable: false,
		//	modal: false,
		//	width: 726,
		//	resizable: false,
		//	position: { my: "right top", at: "right top", of: $("#pagecontainer") }
		//});
		//
		//consoleDialog.dialog("open");
		//$("#logConsole").scrollTop(15);

		$.ajax({
            url: 'ajax/configure?documentRoot=' + encodeURIComponent(VISA.documentRoot) + "&rows=" + encodeURIComponent(tblRowCount) + "&cols=" + encodeURIComponent(tblCellCount) + "&csize=" + encodeURIComponent(cellSize) + "&compMargin=" + encodeURIComponent(componentMargin),
            type: 'GET',
            cache: false,
            async: false,
            success: function (html) {
				response = JSON.parse(html);

				if(response.status === "ajaxSuccess") {
					vsaTemplates = response.vsatemplates;
				}
            	else if (response.status === "ajaxException") {
                    alert('Exception in backend during configure request');
                }
                else if (response.status === "ajaxMissing") {
                    alert('Missing arguments for configure request');
                }
            }
        });

		// Generate the editor grid
		// First, we need a CSS class for the cell size
		$("<style type='text/css'>.gridCell{width: " + String(cellSize) + "px !important; height: " + String(cellSize) + "px !important;}</style>").appendTo("head");

		// Second, iterate through editorRows and editorCols to generate the editor grid
		for(i=0; i<tblRowCount; i++) {
			gridHTML = gridHTML + "<tr>";
			for(j=0; j<tblCellCount; j++) {
				gridHTML = gridHTML + "<td id='c_" + i + "_" + j + "' class='gridCell'></td>";
			}
			gridHTML = gridHTML + "</tr>";
		}

		// Finally, append the trash tables and the editor grid to the DOM
		$("#editorgrid").append(gridHTML);

		$("head").append("<style type='text/css'>.vmtemplate {width:" + 5*cellSize + "px;height:" + 5*cellSize + "px;}</style>");
		$("<div id='new_vm' class='component clone vmtemplate' title='Virtual Machine' data-localize='components.newvm'>Neue VM</div>")
			.appendTo("#inventory")
			.draggable({
				distance: 10,
				grid: [cellSize, cellSize],
				revert: drag_revert,
				obstacle: ".dragbox",
				preventCollision: true,
				start: function(e, ui) {
					$(".qtip").qtip("hide").qtip("disable");
					$(".dragbox").addClass("dragBoxHighlight");
				},
				stop: function(e, ui) {
					$(".qtip").qtip("enable");
					$(".dragbox").removeClass("dragBoxHighlight");
				}
			})
			// Add name tooltips
			.qtip({
				prerender: true,
				content: "Virtual Machine",
				position: {
					my: "bottom center",
					at: "top center"
				}
			});

		$("<div class='spacer'></div>").appendTo("#inventory");

		$("head").append("<style type='text/css'>.switchtemplate {width:" + 10*cellSize + "px;height:" + 3*cellSize + "px;}</style>");
		$("<div id='new_switch' class='component clone switchtemplate' title='Switch' data-localize='components.newswitch'>Neuer Switch</div>")
			.appendTo("#inventory")
			.draggable({
				distance: 10,
				grid: [cellSize, cellSize],
				revert: drag_revert,
				obstacle: ".dragbox",
				preventCollision: true,
				start: function(e, ui) {
					$(".qtip").qtip("hide").qtip("disable");
					$(".dragbox").addClass("dragBoxHighlight");
				},
				stop: function(e, ui) {
					$(".qtip").qtip("enable");
					$(".dragbox").removeClass("dragBoxHighlight");
				}
			})
			// Add name tooltips
			.qtip({
				prerender: true,
				content: "Switch",
				position: {
					my: "bottom center",
					at: "top center"
				}
			});

		$("<div class='spacer'></div>").appendTo("#inventory");

		$("<div id='inventoryAddVSA' class='btn btn-small' data-localize='components.newvsa'>Neue VSA</div>")
			.appendTo("#inventory")
			.on("click", opt_newvsa_click);

		ifOrientationSelect = $(
			"<select name='ifori' class='input-small'>" +
				"<option value='TOP'>oben</option>" +
				"<option value='BOTTOM'>unten</option>" +
				"<option value='LEFT'>links</option>" +
				"<option value='RIGHT'>rechts</option>" +
			"</select>"
		);

		networkSelect = $("<select name='network' class='input-medium'></select>");

		// Request the current topology from the backend
		$.ajax({
			url: 'ajax/requestTopology',
			type: 'GET',
			cache: false,
			async: false,
			success: function (html) {
				response = JSON.parse(html);

				if (response.status === "ajaxException") {
					alert('Exception in backend during topology request');
				}
				else {
					updateTopoStorage(response.topology);

					buildTopology();
				}
			}
		});
	}	//init()


	/**
	 * Initialize the GUI components
	 *
	 * @memberOf VISA
	 */
	function initView() {
		// Load BlockUI mesages into variables
		iotoolBlockUI = $('#blockIOToolComm');

		// Initialize create component dialog
		createCompDialog = $("#createCompDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 500,
			buttons: {
				"Erstellen": createCompDialogOK,
				"Abbrechen": createCompDialogCancel
			}
		});
		$("#createCompDialogSizeApply").on("click.visaDialog", compsize_apply_click);
		$("#createCompDialogIfnumApply").on("click.visaDialog", ifnum_apply_click);

		createVSADialog = $("#createVSADialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 500,
			buttons: {
				"Erstellen": createVSADialogOK,
				"Abbrechen": createVSADialogCancel
			}
		});

		// Initialize cable dialog
		cableDialog = $("#cableDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 450,
			buttons: {
				"Schließen": cableDialogClose
			}
		});
		$("#cableDialogRemove").on("click.visaDialog", cableDialogRemove);

		// Initialize topology dialog
		topologyDialog = $("#topologyDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 300,
			buttons: {
				"OK": topologyDialogOK,
				"Abbrechen": topologyDialogCancel
			},
			beforeClose: function(event, ui) { $("#topologyDialogName").val($("#topologyDialogOldName").val()); }
		});

		// Initialize VLAN dialog
		networkDialog = $("#networkDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 500,
			buttons: {
				"Schließen": vlanDialogClose
			}
		});
		$("#networkDialogCreate").on("click.visaDialog", networkDialogCreate);
		$("#vlanDialogCreate").on("click.visaDialog", vlanDialogCreate);
		$("#vlanDialogSaveEdit").on("click.visaDialog", vlanDialogSaveEdit);
		$("#vlanDialogCancelEdit").on("click.visaDialog", vlanDialogCancelEdit);

		// Initialize IO-Tool dialog
		iotoolDialog = $("#iotoolDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 350,
			buttons: {
				"Schließen": iotoolDialogClose
			}
		});
		$("#iotoolDialogConnect").on("click.visaDialog", iotoolDialogConnect);

		// Initialize RDF/XML dialog
		rdfDialog = $("#rdfDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 300,
			buttons: {
				"Schließen": rdfDialogClose
			}
		});
		$("#rdfDialogExport").on("click.visaDialog", rdfDialogExport);
		$("#rdfDialogStatus").addClass("statusErrorText").append("nicht exportiert");

		// Initialize configure component dialog
		componentDialog = $("#componentDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 800,
			buttons: {
				"OK": componentDialogOK,
				"Abbrechen": componentDialogCancel
			}
		});

		// Initialize reset dialog
		resetDialog = $("#resetDialog").dialog({
			autoOpen: false,
			closeOnEscape: true,
			draggable: false,
			modal: true,
			width: 300,
			buttons: {
				"OK": resetDialogDo,
				"Abbrechen": resetDialogClose
			}
		});

		// Assign event handler to path finding option, manually fire change event to update stored enable value
		// The checkbox is disabled and hidden afterwards since manual pathfinding is currently untested
		$("#optPathFinding")
			.on("change", opt_pathFinder_change)
			.change()
			.attr("disabled", "disabled")
			.parent("div.optionbox").css("display", "none");

		// Assign change event handler to "Show names" button
		$("#optShowNames").change(opt_names_change);

		// Assign change event handler to "Show VLAN" button
		$("#optShowVLAN").change(opt_vlans_change);

		// Initialize export flags
		optExportTopoExported = false;
		optExportDownloadCurrTopo = false;

		// Assign click event handlers to dialog opener buttons
		$("#optTopoConfig").on("click.visaDialog", opt_topoconfigure_click);
		$("#optNetworkDo").on("click.visaDialog", opt_network_click);
		$("#optTopoIOTool").on("click.visaDialog", opt_iotool_click);
		$("#optRDFDo").on("click.visaDialog", opt_rdf_click);
		$("#optResetDo").on("click.visaDialog", opt_reset_click);
		$("#optShutdownDo").on("click.visaDialog", opt_shutdown_click);

		// Assign change event handler to language selection
		$("#optLanguage").on("change.visaDialog", opt_language_change);

		// Do localization
		customLanguage = $.cookie("lang");
		if(customLanguage !== null) {
			// Localize the UI to the set custom language
			$("[data-localize]").localize("visa", {pathPrefix: "i18n", callback: localizeHandler, language: customLanguage});

			// Select the correct language in the language drop down
			$("#optLanguage option[value='" + customLanguage + "']").attr("selected", true);

			// Renew the cookie
			$.cookie("lang", customLanguage, {expires: 14});
		}
		else {
			// Localize the UI to the current browser language
			$("[data-localize]").localize("visa", {pathPrefix: "i18n", callback: localizeHandler});
		}

		// Initialize the context menu for components
		componentContextMenu = $.contextMenu({
			selector: ".component-menu-trigger",
			items: {
				"configure": {
					name: "Konfigurieren",
					callback: menu_cb_configureComponent
				},
				"remove": {
					name: "Entfernen",
					callback: menu_cb_removeComponent
				}
			}
		});

		// Initialize the context menu for components
		//groupContextMenu = $.contextMenu({
		//	selector: ".group-menu-trigger",
		//	items: {
		//		"open": {
		//			name: "Öffnen",
		//			callback: menu_cb_openGroup
		//		}
		//	}
		//});

		// Make the editorgrid a drop target
		$("#editorgrid").droppable({
			tolerance: "fit",
			drop: drag_editor_accept
		});

		// Fill the state list in reset topology dialog if neccessary
		generateStateList();

		// Make inventory and editorgrid visible
		$("#drag").css("visibility", "visible");
	}	//initView()


	/**
	 * Change the status flag of the current export to not up-to-date
	 *
	 * @memberOf VISA
	 */
	function topologyAltered() {
		optExportDownloadCurrTopo = false;

		if(activeIOTopology !== null) {
			$("#iotoolDialogIOSave").removeAttr("disabled");
		}
	}	//topologyAltered()


	/**
	 * Calculate the grid cell coordinates from the offset of an element and the editorgrid offset
	 *
	 * @param {jQuery object} obj jQuery object of the object whose location will be calculated
	 * @param {String} [subgrid=""] Specify the currently active subgrid
	 * @returns {Object} Coordinate object with x, y and obj properties, obj holds a jQuery object of the target cell, null for locations outside the editorgrid
	 * @memberOf VISA
	 */
	function calcGridLocation(obj) {
		var gridOffset,		// Offset (relative to document) of the editorgrid
			objOffset,		// Offset (relative to document) of the provided object
			rv = {},		// Return value object
			subgridStr;

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
		}
		else {
			subgridStr = "";
		}

		// Get the grid's offset
		gridOffset = $("#" + subgridStr + "editorgrid").offset();

		// Get the object's offset
		objOffset = obj.offset();

		// Calculate the grid coordinates of the object
		if(objOffset === undefined || gridOffset === undefined) {
			debugger;
		}
		rv.x = Math.floor((objOffset.left - gridOffset.left) / cellSize);
		rv.y = Math.floor((objOffset.top - gridOffset.top) / cellSize);

		// Handle objects outside the grid, set negative coordinate to 0
		if(rv.x < 0) {
			rv.x = 0;
		}
		if(rv.y < 0) {
			rv.y = 0;
		}

		// Check if the location is a valid grid location
		if(rv.x >= 0 && rv.x < tblCellCount && rv.y >= 0 && rv.y < tblRowCount) {
			if(obj.hasClass("gridCell")) {
				rv.obj = obj;
			}
			else {
				// Get the grid cell object and return the return value object
				rv.obj = $("#" + subgridStr + "c_" + rv.y + "_" + rv.x);
			}

			return rv;
		}
		else {
			// Return null, no valid grid location
			return null;
		}
	}	//calcGridLocation()


	/**
	 * Detect a collision of an object with other dragboxes
	 *
	 * @param {jQuery object} obj Object to check for collisions
	 * @returns {Object} Object with collision, obstacle, shift.x and shift.y attributes
	 * @memberOf VISA
	 */
	function detectCollision(obj) {
		var objBounds = {},		// Boundaries of the object
			subgridStr,
			rv = {},			// Return value object
			tmp;				// Temporary value storage

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
		}
		else {
			subgridStr = "";
		}

		rv.collision = false;	// Flag: true, if an collision was found
		rv.obstacle = null;		// jQuery object of the colliding dragbox
		rv.shift = {};			// Object with x and y attributes, shift of obj required to resolve collision

		// Calculate boundaries of the object
		objBounds.start = calcGridLocation(obj);
		objBounds.end = {};
		objBounds.end.x = objBounds.start.x + (obj.width()/cellSize) - 1;
		objBounds.end.y = objBounds.start.y + (obj.height()/cellSize) - 1;

		// Iterate over all dragboxes to find colliding objects
		$("#" + subgridStr + "dragboxContainer > .dragbox:not(#" + obj.attr("id") + ")").each(function(index, db) {
			var dragbox = $(db),		// jQuery object of the dragbox
				dragboxBounds = {};		// Boundaries of the dragbox

			// Calculate boundaries of the dragbox
			dragboxBounds.start = calcGridLocation(dragbox);
			dragboxBounds.end = {};
			dragboxBounds.end.x = dragboxBounds.start.x + (dragbox.width()/cellSize) - 1;
			dragboxBounds.end.y = dragboxBounds.start.y + (dragbox.height()/cellSize) - 1;

			// Check if any vertical edges of the object collide with horizontal edges of the dragbox
			// Obj: left-vertical
			if(objBounds.start.x >= dragboxBounds.start.x && objBounds.start.x <= dragboxBounds.end.x) {
				// Dragbox: top-horizontal || bottom-horizontal
				if((dragboxBounds.start.y >= objBounds.start.y && dragboxBounds.start.y <= objBounds.end.y) ||
						(dragboxBounds.end.y >= objBounds.start.y && dragboxBounds.end.y <= objBounds.end.y)) {

					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift to the right would be most likely the best solution
					rv.shift.x = (dragboxBounds.end.x + 1) - objBounds.start.x;
				}
				// Obj edge lies completely inside the dragbox, no edge crossing
				else if(objBounds.start.y >= dragboxBounds.start.y && objBounds.end.y <= dragboxBounds.end.y) {
					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift to the right would be most likely the best solution
					rv.shift.x = (dragboxBounds.end.x + 1) - objBounds.start.x;
				}
				else {
					rv.shift.x = 0;
				}
			}
			// Obj: right-vertical
			else if(objBounds.end.x >= dragboxBounds.start.x && objBounds.end.x <= dragboxBounds.end.x) {
				// Dragbox: top-horizontal || bottom-horizontal
				if((dragboxBounds.start.y >= objBounds.start.y && dragboxBounds.start.y <= objBounds.end.y) ||
						(dragboxBounds.end.y >= objBounds.start.y && dragboxBounds.end.y <= objBounds.end.y)) {

					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift to the left would be most likely the best solution
					rv.shift.x = dragboxBounds.start.x - (objBounds.end.x + 1);
				}
				// Obj edge lies completely inside the dragbox, no edge crossing
				else if(objBounds.start.y >= dragboxBounds.start.y && objBounds.end.y <= dragboxBounds.end.y) {
					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift to the left would be most likely the best solution
					rv.shift.x = dragboxBounds.start.x - (objBounds.end.x + 1);
				}
				else {
					rv.shift.x = 0;
				}
			}
			else {
				rv.shift.x = 0;
			}

			// Check if any horizontal edges of the object collide with vertical edges of the dragbox
			// Obj: top-horizontal
			if(objBounds.start.y >= dragboxBounds.start.y && objBounds.start.y <= dragboxBounds.end.y) {
				// Dragbox: left-vertical || right-vertical
				if((dragboxBounds.start.x >= objBounds.start.x && dragboxBounds.start.x <= objBounds.end.x) ||
						(dragboxBounds.end.x >= objBounds.start.x && dragboxBounds.end.x <= objBounds.end.x)) {

					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift downwards would be most likely the best solution
					rv.shift.y = (dragboxBounds.end.y + 1) - objBounds.start.y;
				}
				// Obj edge lies completely inside the dragbox, no edge crossing
				else if(objBounds.start.x >= dragboxBounds.start.x && objBounds.end.x <= dragboxBounds.end.x) {
					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift downwards would be most likely the best solution
					rv.shift.y = (dragboxBounds.end.y + 1) - objBounds.start.y;
				}
				else {
					rv.shift.y = 0;
				}
			}
			// Obj: bottom-horizontal
			else if(objBounds.end.y >= dragboxBounds.start.y && objBounds.end.y <= dragboxBounds.end.y) {
				// Dragbox: left-vertical || right-vertical
				if((dragboxBounds.start.x >= objBounds.start.x && dragboxBounds.start.x <= objBounds.end.x) ||
						(dragboxBounds.end.x >= objBounds.start.x && dragboxBounds.end.x <= objBounds.end.x)) {

					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift upwards would be most likely the best solution
					rv.shift.y = dragboxBounds.start.y - (objBounds.end.y + 1);
				}
				// Obj edge lies completely inside the dragbox, no edge crossing
				else if(objBounds.start.x >= dragboxBounds.start.x && objBounds.end.x <= dragboxBounds.end.x) {
					rv.collision = true;
					rv.obstacle = dragbox;

					// In this case a shift upwards would be most likely the best solution
					rv.shift.y = dragboxBounds.start.y - (objBounds.end.y + 1);
				}
				else {
					rv.shift.y = 0;
				}
			}
			else {
				rv.shift.y = 0;
			}

			// If we detected a collision, do some additional calculations and break the each-loop
			if(rv.collision) {
				console.log("Collision detected: (obj):" + obj.attr("id") + " <-> (obstacle):" + rv.obstacle.attr("id"));

				// Prevent shifting outside the editorgrid
				if(rv.shift.x > 0) {
					// Prevent shifting outside the editorgrid
					tmp = objBounds.end.x + rv.shift.x;
					if(tmp >= tblCellCount) {
						rv.shift.x -= (tmp - (tblCellCount - 1));
					}
				}
				else if(rv.shift.x < 0) {
					// Prevent shifting outside the editorgrid
					tmp = objBounds.start.x + rv.shift.x;
					if(tmp < 0) {
						rv.shift.x -= tmp;
					}
				}

				if(rv.shift.y > 0) {
					// Prevent shifting outside the editorgrid
					tmp = objBounds.end.y + rv.shift.y;
					if(tmp >= tblRowCount) {
						rv.shift.y -= (tmp - (tblRowCount - 1));
					}
				}
				else if(rv.shift.y < 0) {
					// Prevent shifting outside the editorgrid
					tmp = objBounds.start.y + rv.shift.y;
					if(tmp < 0) {
						rv.shift.y -= tmp;
					}
				}

				// Returning false breaks the each() loop
				return false;
			}
			else {
				// Continue each() loop
				return true;
			}
		});

		console.log(rv);
		return rv;
	}	//detectCollision()


	/**
	 * Fit an object into the grid making sure it does not collide with any other object. Works recursively up to a depth of 5 recursions
	 * @param {jQuery object} obj Object to fit into the grid
	 * @param {Integer} depth Optional recursion depth
	 * @returns {boolean} true if fitting was successful, false otherwise
	 * @memberOf VISA
	 */
	function fitObjIntoGrid(obj, depth) {
		var objOffset,		// Position (relative to document) of the object
			status,			// Return value of detectCollision()
			tmpStatus,		// Temporary stored return value of detectCollision()
			gloc,			// Grid location storage
			obstacles = [],	// Store which obstacles already have been processed
			loopLimit,		// Limit how many tries the while-loop will do before breaking positioning
			loopCount,		// Count positioning tries in while-loop
			shiftDirection,
			oldOrigin,
			response,
			rv;

		// If depth is not set we start a new recursion
		if(depth === undefined || depth === null) {
			depth = 0;
		}

		// Break recursion at recursion depth 5 (initial clal + 5 recursive calls)
		if(depth <= 5) {
			objOffset = obj.offset();

			console.log("fitIntoGrid: depth:" + depth + " => Initial collision detection");
			status = detectCollision(obj);

			loopLimit = 20;
			loopCount = 0;
			while(status.collision && loopCount < loopLimit) {
				console.log("fitIntoGrid: depth:" + depth + " => Starting loop " + loopCount);
				obstacles.push(status.obstacle.attr("id"));

				if(status.shift.x !== 0 && status.shift.y !== 0) {
					if(Math.abs(status.shift.x) <= Math.abs(status.shift.y)) {
						shiftDirection = "horizontal";
					}
					else {
						shiftDirection = "vertical";
					}
				}
				else if(status.shift.x !== 0) {
					shiftDirection = "horizontal";
				}
				else {
					shiftDirection = "vertical";
				}

				if(shiftDirection === "horizontal") {
					console.log("fitIntoGrid: depth:" + depth + " => Horizontal shift");
					// Try to shift horizontally
					obj.offset({
						left: objOffset.left + status.shift.x*cellSize,
						top: objOffset.top
					});

					console.log("fitIntoGrid: depth:" + depth + " => Collision detection after horizontal shift");
					// Check collision result at the new position
					tmpStatus = detectCollision(obj);
					if(tmpStatus.collision && $.inArray(tmpStatus.obstacle.attr("id"), obstacles) > -1) {
						console.log("fitIntoGrid: depth:" + depth + " => Vertical shift after horizontal shift");
						// Try to shift vertically
						obj.offset({
							left: objOffset.left,
							top: objOffset.top + status.shift.y*cellSize
						});
					}
				}
				else {
					console.log("fitIntoGrid: depth:" + depth + " => Vertical shift");
					// Try to shift vertically
					obj.offset({
						left: objOffset.left,
						top: objOffset.top + status.shift.y*cellSize
					});

					console.log("fitIntoGrid: depth:" + depth + " => Collision detection after vertical shift");
					// Check collision result at the new position
					tmpStatus = detectCollision(obj);
					if(tmpStatus.collision && $.inArray(tmpStatus.obstacle.attr("id"), obstacles) > -1) {
						console.log("fitIntoGrid: depth:" + depth + " => Horizontal shift after vertical shift");
						// Try to shift horizontally
						obj.offset({
							left: objOffset.left + status.shift.x*cellSize,
							top: objOffset.top
						});
					}
				}

				console.log("fitIntoGrid: depth:" + depth + " => Final collision detection at end of while loop");
				status = detectCollision(obj);
				loopCount++;
			}

			if(loopCount === loopLimit) {
				if(fitObjIntoGrid(status.obstacle, ++depth)) {
					return fitObjIntoGrid(obj);
				}
				else {
					return false;
				}
			}
			else {
				oldOrigin = obj.data("origin");

				// Get the new offset and grid location
				objOffset = obj.offset();
				gloc = calcGridLocation(obj);
				objOffset.x = gloc.x;
				objOffset.y = gloc.y;

				if(oldOrigin === undefined || oldOrigin.x !== objOffset.x || oldOrigin.y !== objOffset.y) {
					// Update origin data in the object
					obj.data("origin", objOffset);

					$.ajax({
						url: 'ajax/relocateComponent?oid=' + encodeURIComponent(obj.data("component").attr("id")) + '&glocX=' + encodeURIComponent(objOffset.x) + '&glocY=' + encodeURIComponent(objOffset.y),
						type: "GET",
						cache: false,
						async: false,
						success: function (html) {
							response = JSON.parse(html);

							if (response.status === "ajaxMissing") {
								// Object relocation failed, reset position of the object
								alert('Missing arguments for relocate component request');
								rv = false;
							}
							else if(response.status === "ajaxException") {
								// Object relocation failed, reset position of the object
								alert('Exception in backend during relocate component request');

								clearEditor();
								buildTopologyBlock();

								rv = false;
							}
							else if(response.status === "ajaxExceptionUnresolved") {
								// Object relocation failed, reset position of the object
								alert('Exception in backend during relocate component request could not be resolved, topology cleared');

								clearEditor();

								rv = false;
							}
							else if(response.status === "ajaxInvalid") {
								// Object relocation failed, reset position of the object
								alert('Invalid object type for relocate component request');
								rv = false;
							}
							else {
								topologyStorage = response.topology;

								// Recalculate obstacles
								calcObstacles();

								rv = true;
							}
						}
					});

					return rv;
				}
				else {
					return true;
				}
			}
		}
		else {
			return false;
		}
	}	//fitObjIntoGrid()


	/**
	 * Create a new topology object. This can be components or groups.
	 *
	 * @param {Object} objInfo Component information object from AJAX response
	 * @param {Object} gloc Override grid location stored in objInfo (optional)
	 * @param {boolean} isDragboxLoc Define if gloc represents a dragbox location (true) or component location (false)
	 * @memberOf VISA
	 */
	function createComponent(objInfo, gloc, isDragboxLoc) {
		var subgridStr,
			dialogOffset = {},
			offsetEditorGrid,
			obj,
			dragBox,
			mouseEventDummy,
			dummyLoopLimits,
			eventDummies,
			tmp,
			i,
			j;

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
			dialogOffset = $("#" + subgridStr + "dialog").parent().offset();
			dialogOffset.top += 1;
			dialogOffset.left += 1;
		}
		else {
			subgridStr = "";
			dialogOffset.top = 0;
			dialogOffset.left = 0;
		}

		// Get the offset of the editorgrid for offset calculations
		offsetEditorGrid = $("#" + subgridStr + "editorgrid").offset();

		// Process gloc parameter if set
		if(gloc !== undefined && gloc !== null) {
			// Adjust component location to dragbox location
			if(isDragboxLoc === false) {
				gloc.x -= objInfo.config.compOffset.x;
				gloc.y -= objInfo.config.compOffset.y;
			}

			// Make sure we will not place the dragbox outside the grid
			// Check top edge
			if(gloc.y < 0) {
				gloc.y = 0;
			}

			// Check bottom edge
			tmp = gloc.y + objInfo.config.dragDim.y;
			if(tmp >= tblRowCount) {
				gloc.y -= (tmp - tblRowCount);
			}

			// Check left edge
			if(gloc.x < 0) {
				gloc.x = 0;
			}

			// Check right edge
			tmp = gloc.x + objInfo.config.dragDim.x;
			if(tmp >= tblCellCount) {
				gloc.x -= (tmp - tblCellCount);
			}

			objInfo.config.gloc = gloc;
		}

		// Calculate the offset values for the dragbox, that is offset of the grid location + editorgrid offset
		objInfo.config.gloc.top = objInfo.config.gloc.y * cellSize + offsetEditorGrid.top - dialogOffset.top;
		objInfo.config.gloc.left = objInfo.config.gloc.x * cellSize + offsetEditorGrid.left - dialogOffset.left;

		// Create and configure the component object
		obj = $("<div></div>")
			.attr("id", objInfo.identifier)
			.attr("title", objInfo.name)
			.addClass("component")
			.css({
				position: "absolute",
				width: (objInfo.config.compDim.x * cellSize) + "px",
				height: (objInfo.config.compDim.y * cellSize) + "px",
				top: (objInfo.config.compOffset.y * cellSize) + "px",
				left: (objInfo.config.compOffset.x * cellSize) + "px"
			})
			.qtip({
				prerender: true,
				position: {
					my: "bottom center",
					at: "top center"
				}
			});

		if(objInfo.isGroup) {
			obj
				.addClass("group-menu-trigger")
				.on("click.visaGroup", group_click)
				.append(htmlEncode(objInfo.name));
		}
		else if(!objInfo.isSwitch && objInfo.isGroupSwitch !== true) {
			obj
				.addClass("component-menu-trigger")
				.append(htmlEncode(shortenNames(objInfo.name)));
		}
		else {
			obj.addClass("component-menu-trigger");
		}

		// Create the mouse event dummy template object
		mouseEventDummy = $("<div class='mouseEventDummy'></div>")
			.on("mouseover.visaDummy", cable_event_propagate)
			.on("mouseout.visaDummy", cable_event_propagate)
			.on("click.visaDummy", cable_event_propagate)
			.on("mousemove.visaDummy", cable_event_propagate);

		// Calculate the coordinate limits between which NO dummies will be placed
		dummyLoopLimits = {};
		dummyLoopLimits.lowerX = objInfo.config.compOffset.x*cellSize - 2*cellSize;
		dummyLoopLimits.upperX = (objInfo.config.dragDim.x*cellSize) - (objInfo.config.dragDim.x - objInfo.config.compOffset.x - objInfo.config.compDim.x)*cellSize + cellSize;
		dummyLoopLimits.lowerY = objInfo.config.compOffset.y*cellSize - 2*cellSize;
		dummyLoopLimits.upperY = (objInfo.config.dragDim.y*cellSize) - (objInfo.config.dragDim.y - objInfo.config.compOffset.y - objInfo.config.compDim.y)*cellSize + cellSize;

		// Create a set of dummies which will be added to the dragbox
		eventDummies = $();
		for(i=0; i<(objInfo.config.dragDim.x*cellSize); i+=10) {
			for(j=0; j<(objInfo.config.dragDim.y*cellSize); j+=10) {
				// Make sure the component and the port markers are not covered by the dummies
				if(!(i>dummyLoopLimits.lowerX &&
						i<dummyLoopLimits.upperX &&
						j>dummyLoopLimits.lowerY &&
						j<dummyLoopLimits.upperY)) {

					// Clone and collect the mouseEventDummies
					eventDummies = eventDummies.add(mouseEventDummy
						.clone(true)
						.css("top", j + "px")
						.css("left", i + "px")
					);
				}
			}
		}

		// Create a dragbox for the component. This box will make sure the component cannot collide with other components and its ports will not be blocked
		dragBox = $("<div></div>")
			.attr("id", objInfo.identifier + "_box")
			.addClass("dragbox")
			.data("component", obj)					// This data holds a jQuery object of the embedded component
			.css({
				position: "absolute",
				width: (objInfo.config.dragDim.x*cellSize) + "px",
				height: (objInfo.config.dragDim.y*cellSize) + "px",
				top: objInfo.config.gloc.top + "px",
				left: objInfo.config.gloc.left + "px"
			})
			.append(obj)
			.append(eventDummies)
			.appendTo("#" + subgridStr + "dragboxContainer")
			.draggable({
				distance: 10,
				grid: [cellSize, cellSize],
				handle: obj,						// The component is the handle, the box is invisible unless needed
				revert: drag_revert,
				obstacle: "#" + subgridStr + "dragboxContainer > .dragbox:not(#" + objInfo.identifier + "_box)",
				containment: "#" + subgridStr + "dragcontainment",
				preventCollision: true,
				preventProtrusion: true,
				start: function(e, ui) {
					$(this).data("component").addClass("dragging");

					// Hide and disable tooltips while dragging
					$(".qtip").qtip("hide").qtip("disable");

					// Make the dragboxes visible
					$("#" + subgridStr + "dragboxContainer > .dragbox").addClass("dragBoxHighlight");
				},
				stop: function(e, ui) {
					// Reenable the tooltips and hide the dragboxes
					$(".qtip").qtip("enable");
					$("#" + subgridStr + "dragboxContainer > .dragbox").removeClass("dragBoxHighlight");
				}
			});

		if(isDragboxLoc) {
			dragBox.data("origin", objInfo.config.gloc);	// This data holds the last known position, required for relocation on failure
		}

		// Add port markers
		markPorts(objInfo);

		// Try to fit the object into the existing topology
		if(fitObjIntoGrid(dragBox)) {
			calcObstacles();

			// TODO do not set topologyAltered here, do it in from caller after successful creation
			// Set the topology altered flag to true
			topologyAltered();

			return dragBox;
		}
		else {
			return null;
		}
	}	//createComponent()


	/**
	 * Request the list of topologies from the IO-Tool and display it in the RDF/XML dialog
	 *
	 * @param {Boolean} [activeButtons=false] true: Activate the Load and Save buttons in the dialog
	 * @memberOf VISA
	 */
	function ioTopoList(activeButtons) {
		if(activeButtons === undefined || activeButtons === null) {
			activeButtons = false;
		}

		// Block UI and execute the query
		blockUI_iotool(function() {
			// Tell the backend to request the topology list from the IO-Tool
			$.ajax({
				url: 'ajax/ioTopoList',
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html),
						connToStr,
						topoList;

					if(response.status === "ajaxSuccess") {
						// Hide the IO-Tool connect panel
						$("#iotoolDialogIOToolConnect").css("display", "none");

						// Build the "connected to" string and the disconnect button
						connToStr = $("<p class='dialogHeadline' data-localize='dialog.iotool.connto'>" + localizeData.dialog.iotool.connto + "</p>");
						connToStr = connToStr.add("<p>" + $("#iotoolDialogHostname").attr("value") + ":" + $("#iotoolDialogPort").attr("value") + "</p>");
						connToStr = connToStr.add("<input id='iotoolDialogDisconnect' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.disconnbutton + "' data-localize='dialog.iotool.disconnbutton' />");

						$("#iotoolDialogIOToolOptions").html(connToStr).css("display", "block");
						$("#iotoolDialogDisconnect").on("click.visaDialog", iotoolDialogDisconnect);

						// Build the list of topologies
						topoList = $("<p class='dialogHeadline' data-localize='dialog.iotool.topolist'>" + localizeData.dialog.iotool.topolist + "</p>");
						$.each(response.data, function(topoID, topoName) {
							topoList = topoList.add("<input id='" + topoID + "_radio' type='radio' name='topo' value='" + topoID + "' />");
							topoList = topoList.add("<label for='" + topoID + "_radio'>" + topoName + "</label><br />");
						});

						// Create the Load, Save and Remove buttons
						topoList = topoList.add("<input id='iotoolDialogIOLoad' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.loadbutton + "' data-localize='dialog.iotool.loadbutton' />");
						topoList = topoList.add("<input id='iotoolDialogIOSave' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.savebutton + "' data-localize='dialog.iotool.savebutton' />");
						topoList = topoList.add("<input id='iotoolDialogIORemove' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.removebutton + "' data-localize='dialog.iotool.removebutton' />");
						topoList = topoList.add("<input id='iotoolDialogIOReplicate' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.replicatebutton + "' data-localize='dialog.iotool.replicatebutton' />");

						// Buttons for demonstrator options
						topoList = topoList.add("<p class='dialogHeadline' data-localize='dialog.iotool.demonstrator'>" + localizeData.dialog.iotool.demonstrator + "</p>");
						topoList = topoList.add("<input id='iotoolDialogIOCollect' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.collectbutton + "' data-localize='dialog.iotool.collectbutton' />");
						topoList = topoList.add("<input id='iotoolDialogIOCleanup' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.cleanupbutton + "' data-localize='dialog.iotool.cleanupbutton' />");
						topoList = topoList.add("<input id='iotoolDialogIOReset' class='btn btn-small' type='button' value='" + localizeData.dialog.iotool.resetbutton + "' data-localize='dialog.iotool.resetbutton' />");

						// Disable buttons depending on the activeButtons setting
						if(!activeButtons) {
							topoList.filter("#iotoolDialogIOLoad").attr("disabled", "disabled");
							topoList.filter("#iotoolDialogIORemove").attr("disabled", "disabled");
							topoList.filter("#iotoolDialogIOReplicate").attr("disabled", "disabled");
						}
						else {
							topoList.find("#" + topologyStorage.identifier + "_radio").attr("checked", "checked");
						}

						$("#iotoolDialogIOToolOptions").append(topoList);

						$("#iotoolDialogIOToolOptions").find("input:radio").on("change.visaDialog", topo_list_change);
						$("#iotoolDialogIOLoad").on("click.visaDialog", iotoolDialogLoad);
						$("#iotoolDialogIOSave").on("click.visaDialog", iotoolDialogSave);
						$("#iotoolDialogIORemove").on("click.visaDialog", iotoolDialogRemove);
						$("#iotoolDialogIOReplicate").on("click.visaDialog", iotoolDialogReplicate);
						$("#iotoolDialogIOCollect").on("click.visaDialog", iotoolDialogCollect);
						$("#iotoolDialogIOCleanup").on("click.visaDialog", iotoolDialogCleanup);
						$("#iotoolDialogIOReset").on("click.visaDialog", iotoolDialogReset);
					}
					else if (response.status === "ajaxGeneral") {
						alert('IO-Tool reported an error during get topology list request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during get topology list request');
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during get topology list request');
					}

					$.unblockUI();
				}
			});
		});
	}	//ioTopoList()


	/**
	 * Display an alert dialog and execute an optional callback when the user closes the dialog
	 *
	 * @param {String} title Title of the dialog
	 * @param {String} msg Message to display in the dialog
	 * @param {Function} [confirmFunc=function(){}] This callback is executed when the user closes the dialog
	 */
	function alertDialog(title, msg, confirmFunc) {
		var diagButtons = {};

		if(confirmFunc === undefined || confirmFunc === null) {
			confirmFunc = function(){};
		}

		diagButtons[localizeData.dialog.alert.ok] = function(){$(this).dialog("destroy"); confirmFunc();};

		$("#confirmDialog")
			.clone()
			.find("#confirmDialogMsg").html(msg).end()
			.attr("title", title)
			.dialog({
				closeOnEscape: false,
				draggable: false,
				modal: true,
				width: 600,
				buttons: diagButtons,
				close: function() {$(this).dialog("destroy"); confirmFunc();}	// Handle event if the user clicks the "X" button
			});
	}	//alertDialog()


	/**
	 * Display a confirm dialog (yes/no) and execute a callback depending on the user's choice.
	 *
	 * @param {String} title Title of the dialog
	 * @param {String} msg Message to display in the dialog
	 * @param {Function} confirmFunc This callback is executed if the user accepts (yes)
	 * @param {Function} [abortFunc=function(){}] This callback is executed if the user declines (no)
	 */
	function confirmDialog(title, msg, confirmFunc, abortFunc) {
		var diagButtons = {};

		if(abortFunc === undefined || abortFunc === null) {
			abortFunc = function(){};
		}

		diagButtons[localizeData.dialog.confirm.yes] = function(){$(this).dialog("destroy"); confirmFunc();};
		diagButtons[localizeData.dialog.confirm.no] = function(){$(this).dialog("destroy"); abortFunc();};

		$("#confirmDialog")
			.clone()
			.find("#confirmDialogMsg").html(msg).end()
			.attr("title", title)
			.dialog({
				closeOnEscape: false,
				draggable: false,
				modal: true,
				width: 600,
				buttons: diagButtons,
				close: function() {$(this).dialog("destroy"); abortFunc();}	// Handle event if the user clicks the "X" button
			});
	}	//confirmDialog()


	/**
	 * Block the GUI when communicationg with the IO-Tool
	 *
	 * @param {Function} callback Function which will be called upon BlockUI's onBlock event
	 * @memberOf VISA
	 */
	function blockUI_iotool(callback) {
		$.blockUI({
			message: iotoolBlockUI,
			onBlock: callback
		});
	}	//blockUI_iotool()


	/**
	 * Block the GUI and start processing of the topologyStorage
	 *
	 * @memberOf VISA
	 */
	function buildTopologyBlock() {
		$.blockUI({
			message: $('#blockBuildTopology'),
			onBlock: buildTopology
		});
	}	//buildTopologyBlock()


	/**
	 * Create draggable objects and cables from the information in topologyStorage
	 *
	 * @memberOf VISA
	 */
	function buildTopology() {
		var globalGrpInfo,
			success;

		if(activeSubgrid === null) {
			globalGrpInfo = topologyStorage.groups["cgroup0"];
		}
		else {
			globalGrpInfo = topologyStorage.groups[activeSubgrid];
		}

		// Add components from the global group
		if(globalGrpInfo.components !== undefined) {
			$.each(globalGrpInfo.components, function(localName, objInfo) {
				createComponent(objInfo, null, true);
			});
		}

		if(activeSubgrid === null) {
			// Add other groups as objects and draw cables connected to this group
			$.each(topologyStorage.groups, function(groupName, grpInfo) {
				if(groupName !== "cgroup0") {
					createComponent(grpInfo, null, true);

					$.each(grpInfo.config.interfaces, function(ifID, ifInfo) {
						var cableID,
							virtCable;

						if(ifInfo.outerConn.isVirtual) {
							virtCable = true;
						}
						else {
							virtCable = false;
						}

						cableStart = $("#" + ifInfo.outerConn.identifier);
						cableEnd = $("#" + ifInfo.identifier);

						// Remove event handlers from the portconnectors
						cableStart
							.off(".visaPorts")
							.off(".visaRouting");
						cableEnd
							.off(".visaPorts")
							.off(".visaRouting");

						removePortConnectorObstacles();

						// Calculate the path from cable start to end
						success = findPath(calcGridLocation(cableStart).obj[0], calcGridLocation(cableEnd).obj[0]);

						// Draw the cable if at least two cable corners were found (start and end cell)
						if(success) {
							cableID = "ncable_virtual_" + nextVirtCableID;
							nextVirtCableID++;

							drawCable(cableID, virtCable);

							// Map the cable to the start and end ports
							cablePortMap[cableStart.attr("id")] = cableID;
							cablePortMap[cableEnd.attr("id")] = cableID;
						}

						// Reset cable start and end objects to null
						cableStart = null;
						cableEnd = null;
					});
				}
			});
		}
		else {
			// Create objects for the group switches if any
			$.each(topologyStorage.groups[activeSubgrid].groupSwitches, function(gswLocName, gswInfo) {
				createComponent(gswInfo, null, true);
			});
		}

		// Draw real cables from global group
		if(globalGrpInfo.cables !== undefined) {
			// Draw all cabled that exist in the initial topology
			$.each(globalGrpInfo.cables, function(objID, objInfo) {
				if(objInfo.via === undefined) {
					var success;

					// Get the objects of the cable start and end portconnectors
					cableStart = $("#" + topologyStorage.interfaces[objInfo.left].identifier);
					cableEnd = $("#" + topologyStorage.interfaces[objInfo.right].identifier);

					// Remove event handlers from the portconnectors
					cableStart
						.off(".visaPorts")
						.off(".visaRouting");
					cableEnd
						.off(".visaPorts")
						.off(".visaRouting");

					removePortConnectorObstacles();

					// Calculate the path from cable start to end
					success = findPath(calcGridLocation(cableStart).obj[0], calcGridLocation(cableEnd).obj[0]);

					// Draw the cable if at least two cable corners were found (start and end cell)
					if(success) {
						drawCable(objID);

						// Map the cable to the start and end ports
						cablePortMap[cableStart.attr("id")] = objID;
						cablePortMap[cableEnd.attr("id")] = objID;
					}

					// Reset cable start and end objects to null
					cableStart = null;
					cableEnd = null;
				}
			});
		}

		// Calculate obstacle markers around the components
		calcObstacles();

		$.unblockUI();
	}	//buildTopology()


	/**
	 * Set the topologyStorage to the object provided as parameter and perform
	 * actions to update several internal infomation storages
	 *
	 * @param {Object} newStorage Object containing the new topology information
	 * @memberOf VISA
	 */
	function updateTopoStorage(newStorage) {
		var cssClasses,
			networkOptions = $(),
			addNewTR = true,
			vlanAssignCells = $(),
			vlanAssignContent,
			i;

		topologyStorage = newStorage;

		console.log(topologyStorage);

		vlanIfCount = {};
		vlanAssignContent = $("<table><tbody></tbody></table>");

		// Create CSS classes for VLAN background-color
		if(topologyStorage.vlans !== undefined && topologyStorage.vlans !== null) {
			cssClasses = $();

			$.each(topologyStorage.vlans, function(vlanID, vlanInfo) {
				vlanIfCount[vlanID] = 0;

				cssClasses = cssClasses.add($("<style data-visa='vlanStyle' type='text/css'>." + vlanID + " {background-color: " + vlanInfo.color + ";}</style>"));

				if(addNewTR === true) {
					vlanAssignCells = vlanAssignCells.add("<tr></tr>");
					addNewTR = false;
				}
				else {
					addNewTR = true;
				}

				vlanAssignCells.last().append("<td><input id='vlanAssign_" + vlanID + "' type='checkbox' value='" + vlanID + "' /><label for='vlanAssign_" + vlanID + "'>" + vlanInfo.name + "</label></td>");
			});

			$("head").find("style[data-visa='vlanStyle']").remove().end().append(cssClasses);

			vlanAssignContent.find("tbody").append(vlanAssignCells);
		}

		if(vlanAssignDialog === undefined || vlanAssignDialog === null) {
			vlanAssignDialog = $("#vlanAssignDialog").dialog({
				autoOpen: false,
				closeOnEscape: true,
				draggable: false,
				modal: true,
				width: 800,
				buttons: {
					"OK": vlanAssignDialogOK,
					"Abbrechen": vlanAssignDialogCancel
				}
			});
		}

		vlanAssignDialog
			.find("#vlanAssignDialogList").empty().append(vlanAssignContent);

		// Count the assigned interfaces per VLAN
		if(topologyStorage.interfaces !== undefined) {
			$.each(topologyStorage.interfaces, function(ifID, ifInfo) {
				for(i=0; i<count(ifInfo.vlan); i++) {
					vlanIfCount[ifInfo.vlan[i].identifier] += 1;
				}
			});
		}

		$("#topologyID").html("ID: " + topologyStorage.identifier);
		$("#topologyDialogID").html(topologyStorage.identifier);

		$("#topologyDialogName").val(htmlDecode(topologyStorage.name));
		$("#topologyDialogOldName").val(htmlDecode(topologyStorage.name));

		networkOptions = networkOptions.add("<option value='none' selected='selected'>---------</option>");
		$.each(topologyStorage.networks, function(netID, network) {
			if(!network.address.address.isLinkLocal) {
				networkOptions = networkOptions.add("<option value='" + netID + "'>" + network.address.address + "/" + network.subnetMask + "</option>");
			}
		});
		networkSelect.html(networkOptions);
	}	//updateTopoStorage()


	/**
	 * Remove any objects and cables from the editor
	 *
	 * @memberOf VISA
	 */
	function clearEditor() {
		$.each(topologyCables, function(cableID, cableInfo) {
			removeCableDrawing(cableInfo.path, cableID);
		});
		topologyCables = {};

		cablePortMap = {};

		$.each(subgridDialogs, function(index, dialog) {
			dialog.dialog("close");
			dialog.parent().remove();
			dialog.remove();
		});
		subgridDialogs = {};

		$("#dragboxContainer").empty();
	}	//clearEditor()


	/**
	 * Remove any objects and cables from currently active subgrid
	 *
	 * @memberOf VISA
	 */
	function clearCurrentSubgrid() {
		if(activeSubgrid !== null) {
			$.each(subgridDialogs[activeSubgrid].data("cables"), function(index, cableID) {
				removeCableDrawing(topologyCables[cableID].path, cableID);

				// Remove information about this cable
				delete cablePortMap[topologyCables[cableID].start.attr("id")];
				delete cablePortMap[topologyCables[cableID].end.attr("id")];
				delete topologyCables[cableID];
			});
			subgridDialogs[activeSubgrid].data("cables", {});

			$("#" + activeSubgrid + "_dragboxContainer").empty();
		}
	}	//clearCurrentSubgrid()


	/**
	 * Generate and show the available states in the reset dialog
	 *
	 * @memberOf VISA
	 */
	function generateStateList() {
		var states;

		if(count(topologyStorage.importHistory) > 0) {
			states = $();
			$.each(topologyStorage.importHistory, function(index, entry) {
				states = states.add("<input id='state" + index + "' type='radio' name='reset' value='" + index + "' /><label for='state" + index + "'>" + localizeData.dialog.reset.statebox.importof + " " + entry + "</label><br />");
			});
			$("#resetDialogStateList").empty().append(states);
		}
	}	//generateStateList()


	/**
	 * Request to disable dragging
	 *
	 * @memberOf VISA
	 */
	function lockDrag() {
		// Disable dragging if this is the first lock request
		if(dragLocks === 0) {
			$(".ui-draggable").draggable("disable");
		}

		// Increase lock counter
		dragLocks++;

	}	//lockDrag()


	/**
	 * Release a drag lock to renenable dragging. Dragging is only enabled if the last lock is removed
	 *
	 * @memberOf VISA
	 */
	function releaseDrag() {
		// Only do something if dragging is disabled <=> at least 1 lock is existing
		if(dragLocks > 0) {
			// Decrease lock counter
			dragLocks--;

			// If we just removed the last lock, reenable dragging
			if(dragLocks === 0) {
				$(".ui-draggable").draggable("enable");
			}
		}
	}	//releaseDrag()


	/**
	 * Block the UI with a message stating that the backend is not running
	 *
	 * @memberOf VISA
	 */
	function backendDown() {
		$.blockUI({
			message: $('#blockBackendDown')
		});
	}	//backendDown()


	/**
	 * Mark the cells next to the ports of a component or group
	 *
	 * @param {Object} objInfo Component information object from AJAX response
	 * @memberOf VISA
	 */
	function markPorts(objInfo) {
		var obj,
			objOffset,
			objPorts,				// jQuery objects of the portconnectors
			setInterfaces = {},
			portImageClass,
			port;

		obj = $("#" + objInfo.identifier);

		// Get object offset and initialize ports object with an empty jQuery object
		objOffset = obj.offset();
		objPorts = $();
		setInterfaces.top = 0;
		setInterfaces.bottom = 0;
		setInterfaces.left = 0;
		setInterfaces.right = 0;

		if(objInfo.isSwitch) {
			if(objInfo.realIf !== undefined) {
				$.each(objInfo.realIf, function(index, ifInfo) {
					var ifOffset;

					ifOffset = {};

					// Calculate top and left offsets depending in interface orientation
					switch(ifInfo.orientation) {
						case "TOP":
							ifOffset.top = cellSize*-1;
							ifOffset.left = setInterfaces.top*cellSize;
							portImageClass = "portconnUp";
							setInterfaces.top++;
							break;
						case "LEFT":
							ifOffset.top = objInfo.config.compDim.y*cellSize - cellSize - setInterfaces.left*cellSize;
							ifOffset.left = cellSize*-1;
							portImageClass = "portconnLeft";
							setInterfaces.left++;
							break;
						case "RIGHT":
							ifOffset.top = setInterfaces.right*cellSize;
							ifOffset.left = objInfo.config.compDim.x*cellSize;
							portImageClass = "portconnRight";
							setInterfaces.right++;
							break;
						case "BOTTOM":
							ifOffset.top = objInfo.config.compDim.y*cellSize;
							ifOffset.left = objInfo.config.compDim.x*cellSize - cellSize - setInterfaces.bottom*cellSize;
							portImageClass = "portconnDown";
							setInterfaces.bottom++;
							break;
					}

					// Finally add the portconnector
					port = $("<div></div>")
						.attr("id", ifInfo.identifier)
						.addClass("portconnector " + portImageClass + " " + objInfo.identifier)
						.css({
							top: ifOffset.top + "px",
							left: ifOffset.left + "px"
						})
						.data("orientation", ifInfo.orientation)
						.data("component", obj)
						.appendTo(obj)
						.on("mousedown.visaPorts", port_mousedown)
						.on("mousemove.visaRouting", port_mousemove_propagate);

					if(ifInfo.vlan !== undefined) {
						port.addClass("vlan")
							.data("vlan", ifInfo.vlan);
					}

					objPorts = objPorts.add(port);
				});
			}

			if(objInfo.virtIf !== undefined) {
				$.each(objInfo.virtIf, function(index, ifInfo) {
					var ifOffset;

					ifOffset = {};

					// Calculate top and left offsets depending in interface orientation
					switch(ifInfo.orientation) {
						case "TOP":
							ifOffset.top = cellSize*-1;
							ifOffset.left = setInterfaces.top*cellSize;
							portImageClass = "portconnUpVirt";
							setInterfaces.top++;
							break;
						case "LEFT":
							ifOffset.top = objInfo.config.compDim.y*cellSize - cellSize - setInterfaces.left*cellSize;
							ifOffset.left = cellSize*-1;
							portImageClass = "portconnLeftVirt";
							setInterfaces.left++;
							break;
						case "RIGHT":
							ifOffset.top = setInterfaces.right*cellSize;
							ifOffset.left = objInfo.config.compDim.x*cellSize;
							portImageClass = "portconnRightVirt";
							setInterfaces.right++;
							break;
						case "BOTTOM":
							ifOffset.top = objInfo.config.compDim.y*cellSize;
							ifOffset.left = objInfo.config.compDim.x*cellSize - cellSize - setInterfaces.bottom*cellSize;
							portImageClass = "portconnDownVirt";
							setInterfaces.bottom++;
							break;
					}

					// Finally add the portconnector
					port = $("<div></div>")
						.attr("id", ifInfo.identifier)
						.addClass("portconnector " + portImageClass + " " + objInfo.identifier)
						.css({
							top: ifOffset.top + "px",
							left: ifOffset.left + "px"
						})
						.data("orientation", ifInfo.orientation)
						.data("component", obj)
						.appendTo(obj);

					if(ifInfo.vlan !== undefined) {
						port.addClass("vlan")
							.data("vlan", ifInfo.vlan);
					}

					objPorts = objPorts.add(port);
				});
			}
		}
		else {
			$.each(objInfo.config.interfaces, function(index, ifInfo) {
				var ifOffset;

				ifOffset = {};

				// Calculate top and left offsets depending in interface orientation
				switch(ifInfo.orientation) {
					case "TOP":
						ifOffset.top = cellSize*-1;
						ifOffset.left = setInterfaces.top*cellSize;
						portImageClass = "portconnUp";
						setInterfaces.top++;
						break;
					case "LEFT":
						ifOffset.top = objInfo.config.compDim.y*cellSize - cellSize - setInterfaces.left*cellSize;
						ifOffset.left = cellSize*-1;
						portImageClass = "portconnLeft";
						setInterfaces.left++;
						break;
					case "RIGHT":
						ifOffset.top = setInterfaces.right*cellSize;
						ifOffset.left = objInfo.config.compDim.x*cellSize;
						portImageClass = "portconnRight";
						setInterfaces.right++;
						break;
					case "BOTTOM":
						ifOffset.top = objInfo.config.compDim.y*cellSize;
						ifOffset.left = objInfo.config.compDim.x*cellSize - cellSize - setInterfaces.bottom*cellSize;
						portImageClass = "portconnDown";
						setInterfaces.bottom++;
						break;
				}

				// Finally add the portconnector
				port = $("<div></div>")
					.attr("id", ifInfo.identifier)
					.addClass("portconnector " + portImageClass + " " + objInfo.identifier)
					.css({
						top: ifOffset.top + "px",
						left: ifOffset.left + "px"
					})
					.data("orientation", ifInfo.orientation)
					.data("component", obj)
					.appendTo(obj)
					.on("mousedown.visaPorts", port_mousedown)
					.on("mousemove.visaRouting", port_mousemove_propagate);

				if(ifInfo.vlan !== undefined) {
					port.addClass("vlan")
						.data("vlan", ifInfo.vlan);
				}

				objPorts = objPorts.add(port);
			});
		}

		// Store the portconnector objects as data in the component
		obj.data("portObjs", objPorts);
	}	//markPorts()


	/**
	 * Calculate obstacles on the editor grid
	 *
	 * @memberOf VISA
	 */
	function calcObstacles() {
		// TODO allow partial recalculation (only recalculate moved objects), speeding things up
		var subgridStr;

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
		}
		else {
			subgridStr = "";
		}

		// Remove all obstacle markers from the grid
		$("#" + subgridStr + "editorgrid .obstacle").removeClass("obstacle");

		// Iterate over all found objects that have the class "component" and are located inside the "editorgrid"
		$("#" + subgridStr + "dragboxContainer .component").each(function(index, obj) {
			var coords,			// Grid location of the object
				size = {},		// Size of the object in grid cells
				start = {},		// First grid coordinate to mark as obstacle
				end = {},		// Last grid coordinate to mark as obstacle
				i,				// for-loop counter, vertical coordinate
				j;				// for-loop counter, horizontal coordinate

			obj = $(obj);

			// Get the coordinates of the object
			coords = calcGridLocation(obj);

			// Get the size of the object
			size.x = obj.width() / cellSize;
			size.y = obj.height() / cellSize;

			// We want a 2 cells wide free space around every object
			// Determine starting coordinates of the free space (top left)
			start.x = coords.x - componentMargin;
			start.y = coords.y - componentMargin;

			// Prevent negative starting coordinates
			if(start.x < 0) {
				start.x = 0;
			}
			if(start.y < 0) {
				start.y = 0;
			}

			// Determine ending coordinates of the free space (bottom right)
			end.x = coords.x + size.x + componentMargin;
			end.y = coords.y + size.y + componentMargin;

			// Prevending ending coordinates outside the grid
			if(end.x >= tblCellCount) {
				end.x = tblCellCount - 1;
			}
			if(end.y >= tblRowCount) {
				end.y = tblRowCount - 1;
			}

			// Mark all obstacles
			for(i=start.y; i<end.y; i++) {
				for(j=start.x; j<end.x; j++) {
					if(!$("#" + subgridStr + "c_" + i + "_" + j).hasClass("cable")) {
						$("#" + subgridStr + "c_" + i + "_" + j).addClass("obstacle");
					}
				}
			}
		});
	}	//calcObstacles()


	/**
	 * Handle mousedown events on port markers
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function port_mousedown(e) {
		var cableID,	// ID of the new cable
			gloc = {},	// Grid location storage
			success;	// Flag: true, if path was found, false otherwise

		// Check if a cable was already started
		if(cableStart === null) {
			// Request to disable dragging if neccessary
			lockDrag();

			// Disable path finding checkbox, so we'll not mix multiple path finding methods
			$("#optPathFinding").attr('disabled', true);

			// Set the cable start to the clicked element
			cableStart = $(e.target);
			cableStart.addClass("portconnectorHighlight");

			// Disable mousedown handler on the clicked element
			cableStart.off("mousedown.visaPorts");

			if(!optPathFinderEnable) {
				// Add the cable start to the cableCorners
				cableCorners.unshift(calcGridLocation(cableStart).obj[0]);

				// Enable mousemove handler on the editor to track mouse movement over grid cells
				$("#editorgrid").on("mousemove.visaRouting", "td", pathfinding_mousemove);
			}
		}
		else {
			// Only do these calculation when automatic routing is disabled
			// Otherwise the undefined objects do not matter since they are not used below
			// (optPathFinderEnable==true so anything else in the if statement is ignored)
			if(!optPathFinderEnable) {
				gloc.corner = calcGridLocation($(cableCorners[cableCorners.length-1]));
				gloc.end = calcGridLocation($(e.target));
			}

			// Only process this event if:
			// automatic routing is enabled
			// or the last cable corner has a position that makes connection to this portconnector possible
			if(optPathFinderEnable ||
				(gloc.end.x === gloc.corner.x &&
					((gloc.end.y > gloc.corner.y && $(e.target).data("orientation") === "TOP") ||
					(gloc.end.y < gloc.corner.y && $(e.target).data("orientation") === "BOTTOM"))
				) ||
				(gloc.end.y === gloc.corner.y &&
					((gloc.end.x > gloc.corner.x && $(e.target).data("orientation") === "LEFT") ||
					(gloc.end.x < gloc.corner.x && $(e.target).data("orientation") === "RIGHT"))
				)
			) {

				// Set the cable end to the clicked element
				cableEnd = $(e.target);
				cableEnd.addClass("portconnectorHighlight");

				// Disable mousedown handler on the clicked element
				cableEnd.off("mousedown.visaPorts");

				// Calculate grid locations for start and end portconnectors
				gloc.start = calcGridLocation(cableStart);
				gloc.end = calcGridLocation(cableEnd);

				// Open path to portconnectors
				removePortConnectorObstacles();

				if(!optPathFinderEnable) {
					// Add the cable end to the cableCorners
					cableCorners.push(calcGridLocation(cableEnd).obj[0]);
					success = true;

					// Remove the mousemove handler from the editorgrid
					$("#editorgrid").off("mousemove.visaRouting");

					// Remove the click handler from the last cell
					lastCell.removeClass("cableCornerAllowed cableCornerNotAllowed").off(".visaRouting");
				}
				else {
					success = findPath(gloc.start.obj[0], gloc.end.obj[0]);
				}

				if(success) {
					cableID = createCable();

					// Map the cable to the start and end ports
					cablePortMap[cableStart.attr("id")] = cableID;
					cablePortMap[cableEnd.attr("id")] = cableID;

					// Reset cable ID
					cableID = null;
				}
				else {
					// Reenable event handlers of portconnectors
					cableStart.on("mousedown.visaPorts", port_mousedown);
					cableEnd.on("mousedown.visaPorts", port_mousedown);
				}

				// Reset cableStart, cableEnd and cableCorners
				cableStart.removeClass("portconnectorHighlight");
				cableStart = null;

				cableEnd.removeClass("portconnectorHighlight");
				cableEnd = null;

				cableCorners = [];

				// Reenable path finding checkbox
				$("#optPathFinding").removeAttr('disabled');

				// Release the drag lock and reenable dragging if possible
				releaseDrag();
			}
		}
	}	//port_mousedown()


	/**
	 * Propagate mousemove events on portconnectors to the grid cell below
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function port_mousemove_propagate(e) {
		var gloc;	// Grid location of the event target

		// Only propagate if automatic routing is disabled
		if(!optPathFinderEnable) {
			// Get the grid location of the event target
			gloc = calcGridLocation($(e.target));

			// Tell the handler this was propagated by a portconnector
			e.portconnector = true;
			e.portOrientation = $(e.target).data("orientation");

			// Set the event target to the grid cell
			e.target = gloc.obj[0];

			// Propagate the event by triggering it on the grid cell
			gloc.obj.trigger(e);
		}
	}	//port_mousemove_propagate


	/**
	 * Handle mousemove events when automatic routing is disabled, track the position of the mouse
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function pathfinding_mousemove(e) {
		var lastCornerLoc,		// Grid location of the last added cable corner
			lastCellLoc,		// Grid location of the current cell
			newTmpPathCell,		// The cell which will be added to the temporary path next
			subgridStr,
			regExID,			// Cable ID found with the regex
			parallelCable,		// If true, a parallel overlapping cable was found
			parallelCableID,	// ID of a passibly parallel overlapping cable
			i;					// for-loop counter

		// Remove background color from the lastCell and disable click event handler if it is set
		if(lastCell !== null && lastCell.length > 0) {
			lastCell
				.removeClass("cableCornerAllowed cableCornerNotAllowed")
				.off("click.visaRouting");
		}

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
		}
		else {
			subgridStr = "";
		}

		// Update the lastCell to the current cell
		lastCell = $(e.target);

		// Get the grid location of the last added path corner
		lastCornerLoc = calcGridLocation($(cableCorners[cableCorners.length-1]));

		// Get the grid location of the current cell
		lastCellLoc = calcGridLocation(lastCell);

		// Remove the class .tmpPath from all elements (hide old temporary path)
		tmpPathCells.removeClass("tmpPath");
		tmpPathCells = $();

		parallelCable = false;

		// Check if horizontal coordinates of the current cell and the last path corner match
		if((e.portconnector === true || cableCorners.length <= 1 || !lastCell.hasClass("obstacle")) && lastCornerLoc.x === lastCellLoc.x && !lastCell.hasClass("cable")) {
			// Setting a path corner in this location is allowed
			// Reenable click event handler
			lastCell.on("click.visaRouting", pathfinding_click);

			// Change the style of the current cell
			lastCell.addClass("cableCornerAllowed");

			// Check in which direction the new temporary path has to be drawn
			if(lastCornerLoc.y < lastCellLoc.y) {
				// Draw the new temporary path downwards
				for(i=lastCornerLoc.y+1; i<lastCellLoc.y; i++) {
					newTmpPathCell = $("#" + subgridStr + "c_" + i + "_" + lastCellLoc.x);

					if(newTmpPathCell.attr("class").match(/\b(ncable(_virtual)?_\d+)\b/)) {
						regExID = RegExp.$1;

						if(parallelCableID === undefined) {
							parallelCableID = regExID;
						}
						else {
							if(parallelCableID === regExID) {
								parallelCable = true;
							}
							else {
								parallelCableID = regExID;
							}
						}
					}

					if(!parallelCable) {
						// Check if the path does not cross an obstacle
						if((e.portconnector === true && e.portOrientation === "TOP") ||
								(cableCorners.length <= 1 && cableStart.data("orientation") === "BOTTOM") ||
								!newTmpPathCell.hasClass("obstacle")) {

							newTmpPathCell.addClass("tmpPath");
							tmpPathCells = tmpPathCells.add(newTmpPathCell);
						}
						else{
							// Obstacle detected, remove the already drawn tmpPath
							tmpPathCells.removeClass("tmpPath");
							tmpPathCells = $();

							// Update style on lastCell and remove click handler
							lastCell
								.off("click.visaRouting")
								.removeClass("cableCornerAllowed")
								.addClass("cableCornerNotAllowed");

							// Break loop, path is not allowed
							break;
						}
					}
					else {
						// Parallel overlapping cable detected, remove the already drawn tmpPath
						tmpPathCells.removeClass("tmpPath");
						tmpPathCells = $();

						// Update style on lastCell and remove click handler
						lastCell
							.off("click.visaRouting")
							.removeClass("cableCornerAllowed")
							.addClass("cableCornerNotAllowed");

						// Break loop, path is not allowed
						break;
					}
				}
			}
			else {
				// Draw the new temporary path upwards
				for(i=lastCornerLoc.y-1; i>lastCellLoc.y; i--) {
					newTmpPathCell = $("#" + subgridStr + "c_" + i + "_" + lastCellLoc.x);

					if(newTmpPathCell.attr("class").match(/\b(ncable(_virtual)?_\d+)\b/)) {
						regExID = RegExp.$1;

						if(parallelCableID === undefined) {
							parallelCableID = regExID;
						}
						else {
							if(parallelCableID === regExID) {
								parallelCable = true;
							}
							else {
								parallelCableID = regExID;
							}
						}
					}

					if(!parallelCable) {
						// Check if the path does not cross an obstacle
						if((e.portconnector === true && e.portOrientation === "BOTTOM") ||
								(cableCorners.length <= 1 && cableStart.data("orientation") === "TOP") ||
								!newTmpPathCell.hasClass("obstacle")) {

							newTmpPathCell.addClass("tmpPath");
							tmpPathCells = tmpPathCells.add(newTmpPathCell);
						}
						else{
							// Obstacle detected, remove the already drawn tmpPath
							tmpPathCells.removeClass("tmpPath");
							tmpPathCells = $();

							// Update style on lastCell and remove click handler
							lastCell
								.off("click.visaRouting")
								.removeClass("cableCornerAllowed")
								.addClass("cableCornerNotAllowed");

							// Break loop, path is not allowed
							break;
						}
					}
					else {
						// Parallel overlapping cable detected, remove the already drawn tmpPath
						tmpPathCells.removeClass("tmpPath");
						tmpPathCells = $();

						// Update style on lastCell and remove click handler
						lastCell
							.off("click.visaRouting")
							.removeClass("cableCornerAllowed")
							.addClass("cableCornerNotAllowed");

						// Break loop, path is not allowed
						break;
					}
				}
			}
		}
		// Check if vertical coordinates of the current cell and the last path corner match
		else if((e.portconnector === true || cableCorners.length <= 1 || !lastCell.hasClass("obstacle")) && lastCornerLoc.y === lastCellLoc.y) {
			// Setting a path corner in this location is allowed
			// Reenable click event handler
			lastCell.on("click.visaRouting", pathfinding_click);

			// Change the style of the current cell
			lastCell.addClass("cableCornerAllowed");

			// Check in which direction the new temporary path has to be drawn
			if(lastCornerLoc.x < lastCellLoc.x) {
				// Draw the new temporary path right
				for(i=lastCornerLoc.x+1; i<lastCellLoc.x; i++) {
					newTmpPathCell = $("#" + subgridStr + "c_" + lastCellLoc.y + "_" + i);

					if(newTmpPathCell.attr("class").match(/\b(ncable(_virtual)?_\d+)\b/)) {
						regExID = RegExp.$1;

						if(parallelCableID === undefined) {
							parallelCableID = regExID;
						}
						else {
							if(parallelCableID === regExID) {
								parallelCable = true;
							}
							else {
								parallelCableID = regExID;
							}
						}
					}

					if(!parallelCable) {
						// Check if the path does not cross an obstacle
						if((e.portconnector === true && e.portOrientation === "LEFT") ||
								(cableCorners.length <= 1 && cableStart.data("orientation") === "RIGHT") ||
								!newTmpPathCell.hasClass("obstacle")) {

							newTmpPathCell.addClass("tmpPath");
							tmpPathCells = tmpPathCells.add(newTmpPathCell);
						}
						else{
							// Obstacle detected, remove the already drawn tmpPath
							tmpPathCells.removeClass("tmpPath");
							tmpPathCells = $();

							// Update style on lastCell and remove click handler
							lastCell
								.off("click.visaRouting")
								.removeClass("cableCornerAllowed")
								.addClass("cableCornerNotAllowed");

							// Break loop, path is not allowed
							break;
						}
					}
					else {
						// Parallel overlapping cable detected, remove the already drawn tmpPath
						tmpPathCells.removeClass("tmpPath");
						tmpPathCells = $();

						// Update style on lastCell and remove click handler
						lastCell
							.off("click.visaRouting")
							.removeClass("cableCornerAllowed")
							.addClass("cableCornerNotAllowed");

						// Break loop, path is not allowed
						break;
					}
				}
			}
			else {
				// Draw the new temporary path left
				for(i=lastCornerLoc.x-1; i>lastCellLoc.x; i--) {
					newTmpPathCell = $("#" + subgridStr + "c_" + lastCellLoc.y + "_" + i);

					if(newTmpPathCell.attr("class").match(/\b(ncable(_virtual)?_\d+)\b/)) {
						regExID = RegExp.$1;

						if(parallelCableID === undefined) {
							parallelCableID = regExID;
						}
						else {
							if(parallelCableID === regExID) {
								parallelCable = true;
							}
							else {
								parallelCableID = regExID;
							}
						}
					}

					if(!parallelCable) {
						// Check if the path does not cross an obstacle
						if((e.portconnector === true && e.portOrientation === "RIGHT") ||
								(cableCorners.length <= 1 && cableStart.data("orientation") === "LEFT") ||
								!newTmpPathCell.hasClass("obstacle")) {

							newTmpPathCell.addClass("tmpPath");
							tmpPathCells = tmpPathCells.add(newTmpPathCell);
						}
						else{
							// Obstacle detected, remove the already drawn tmpPath
							tmpPathCells.removeClass("tmpPath");
							tmpPathCells = $();

							// Update style on lastCell and remove click handler
							lastCell
								.off("click.visaRouting")
								.removeClass("cableCornerAllowed")
								.addClass("cableCornerNotAllowed");

							// Break loop, path is not allowed
							break;
						}
					}
					else {
						// Parallel overlapping cable detected, remove the already drawn tmpPath
						tmpPathCells.removeClass("tmpPath");
						tmpPathCells = $();

						// Update style on lastCell and remove click handler
						lastCell
							.off("click.visaRouting")
							.removeClass("cableCornerAllowed")
							.addClass("cableCornerNotAllowed");

						// Break loop, path is not allowed
						break;
					}
				}
			}
		}
		else {
			// Setting a path corner in this location is not allowed
			// Change the style of the current cell
			lastCell.addClass("cableCornerNotAllowed");
		}
	}	//pathfinding_mousemove()


	/**
	 * Handle click events on the grid when path finding is disabled, mark cable corners
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function pathfinding_click(e) {
		if(!optPathFinderEnable && lastCell.length > 0 && $.inArray(lastCell[0], cableCorners) === -1) {
			// TODO optical improvements of cableCorner, tmpPath and newPath classes needed
			// Add the class newPath to all tmpPath cells and remove tmpPath class
			newPathCells = newPathCells.add(tmpPathCells.removeClass("tmpPath").addClass("newPath"));
			tmpPathCells = $();

			// Set the current cell as cableCorner
			lastCell
				.removeClass("cableCornerAllowed")
				.addClass("cableCorner")
				.off(".visaRouting");

			// Add the current cell to cableCorners
			cableCorners.push(lastCell[0]);
		}
	}	//pathfinding_click()


	/**
	 * Handle click events on groups, open the group dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function group_click(e) {
		var obj = $(e.target),
			dialog,
			gridDim,
			gridHTML = "",
			i,
			j;

		if(!obj.hasClass("dragging")) {
			activeSubgrid = e.target.id;

			if(subgridDialogs[activeSubgrid] === undefined) {
				dialog = $("#subgridDialogTemplate")
					.clone(true)
					.attr("id", activeSubgrid + "_dialog")
					.attr("title", "Komponentengruppe " + topologyStorage.groups[activeSubgrid].name)
					.data("cables", {});

				gridDim = topologyStorage.groups[activeSubgrid].config.gridDim;

				for(i=0; i<gridDim.y; i++) {
					gridHTML = gridHTML + "<tr>";
					for(j=0; j<gridDim.x; j++) {
						gridHTML = gridHTML + "<td id='" + activeSubgrid + "_c_" + i + "_" + j + "' class='gridCell'></td>";
					}
					gridHTML = gridHTML + "</tr>";
				}

				dialog.find("table")
					.attr("id", activeSubgrid + "_editorgrid")
					.append(gridHTML);

				dialog.find("#subgridDragboxContainer")
					.attr("id", activeSubgrid + "_dragboxContainer");

				dialog.find("#subgridDragcontainment")
					.attr("id", activeSubgrid + "_dragcontainment");

				dialog.find("#subgridInventorytabs")
					.attr("id", activeSubgrid + "_inventorytabs");

				dialog.dialog({
					autoOpen: false,
					closeOnEscape: true,
					draggable: false,
					modal: true,
					width: 1779,
					height: 1000,
					buttons: {
						"Schließen": groupDialogClose
					},
					beforeClose: function(event, ui) {
						// Disable the droppable inside the dialog
						$("#" + activeSubgrid + "_editorgrid").droppable("option", "disabled", true);
					},
					close: function(event, ui){
						activeSubgrid = null;

						// Move the inventory back to the base layer
						$("#inventory")
							.find("#inventoryAddVSA").css("visibility", "visible").end()
							.appendTo($("#inventorytabs"));

						// Enable the droppable for the base layer editor grid
						$("#editorgrid").droppable("option", "disabled", false);
					}
				});

				subgridDialogs[activeSubgrid] = dialog;

				// Move the inventory to the new dialog
				$("#inventory")
					.find("#inventoryAddVSA").css("visibility", "hidden").end()
					.appendTo(dialog.find("#" + activeSubgrid + "_inventorytabs"));

				dialog.dialog("open");

				$("#" + activeSubgrid + "_editorgrid").droppable({
					tolerance: "fit",
					drop: drag_editor_accept
				});

				buildTopology();
			}
			else {
				dialog = subgridDialogs[activeSubgrid];

				// Move the inventory to the dialog
				$("#inventory")
					.find("#inventoryAddVSA").css("visibility", "hidden").end()
					.appendTo(dialog.find("#" + activeSubgrid + "_inventorytabs"));

				dialog.dialog("open");

				$("#" + activeSubgrid + "_editorgrid").droppable("option", "disabled", false);
			}

			$("#editorgrid").droppable("option", "disabled", true);
		}
		else {
			// Ignore click event since the object was moved and not clicked
			obj.removeClass("dragging");
		}
	}	//group_click()


	/**
	 * Handle mouseover events on existing cables to highlight the cable
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function cable_mouseover(e) {
		e.target.className.match(/\b(ncable(_virtual)?_\d+)\b/);

		topologyCables[RegExp.$1].path.addClass("cableHighlight");
	}	//cable_mouseover()


	/**
	 * Handle mouseout events on existing cables to remove highlighting
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function cable_mouseout(e) {
		e.target.className.match(/\b(ncable(_virtual)?_\d+)\b/);

		topologyCables[RegExp.$1].path.removeClass("cableHighlight");
	}	//cable_mouseout()


	/**
	 * Handle mousedown events on cable to open the cable detail dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function cable_click(e) {
		var cableID,				// ID of the clicked cable
			cableIsVirtual,
			leftComponentTitle,		// Title of the object connected at the left cable end
			rightComponentTitle,	// Title of the object connected at the right cable end
			vlanString;

		// We're only interested in primary clicks
		if(e.which === 1) {
			// Get the cable ID
			e.target.className.match(/\b(ncable(_virtual)?_\d+)\b/);
			cableID = RegExp.$1;
			cableIsVirtual = (RegExp.$2 === "_virtual");
			$("#cableDialogID").val(cableID);

			// Get title of left and right component
			leftComponentTitle = topologyCables[cableID].start.data("component").attr("title");
			rightComponentTitle = topologyCables[cableID].end.data("component").attr("title");

			// Update texts in the dialog
			$("#cableDialogLeft").empty();
			$("#cableDialogLeft").append("<span class='dialogHeadline'>" + localizeData.dialog.cable.componentbox.from + ":</span><br />" + leftComponentTitle);

			$("#cableDialogRight").empty();
			$("#cableDialogRight").append("<span class='dialogHeadline'>" + localizeData.dialog.cable.componentbox.to + ":</span><br />" + rightComponentTitle);

			$("#cableDialogVLAN").empty();

			// Generate the VLAN info string
			// Add headline
			vlanString = "<span class='dialogHeadline'>VLAN:</span><br />";

			// If both interfaces declare VLANs (switch to switch connection)
			if(count(topologyCables[cableID].start.data("vlan")) > 0 && count(topologyCables[cableID].end.data("vlan")) > 0) {
				// Process all VLANs at start interface
				$.each(topologyCables[cableID].start.data("vlan"), function(index, vlanInfo) {
					if(parseInt(index, 10) > 0) {
						vlanString += "<span class='vlanListText'>, </span>";
					}

					vlanString += "<div class='vlanListColorBox' style='background-color:" + vlanInfo.color + ";'></div>";
					vlanString += "<span class='vlanListText'>" + vlanInfo.name + "</span>";
				});

				// Add separator
				vlanString += "<span class='vlanListText'> / </span>";

				// Process all VLANs at end interface
				$.each(topologyCables[cableID].end.data("vlan"), function(index, vlanInfo) {
					if(parseInt(index, 10) > 0) {
						vlanString += "<span class='vlanListText'>, </span>";
					}

					vlanString += "<div class='vlanListColorBox' style='background-color:" + vlanInfo.color + ";'></div>";
					vlanString += "<span class='vlanListText'>" + vlanInfo.name + "</span>";
				});

				// Append the string to the dialog
				$("#cableDialogVLAN")
					.append(vlanString)
					.css("display", "block");
			}
			// If only start interface declares a VLAN
			else if(count(topologyCables[cableID].start.data("vlan")) > 0) {
				// Process all VLANs at start interface
				$.each(topologyCables[cableID].start.data("vlan"), function(index, vlanInfo) {
					if(parseInt(index, 10) > 0) {
						vlanString += "<span class='vlanListText'>, </span>";
					}

					vlanString += "<div class='vlanListColorBox' style='background-color:" + vlanInfo.color + ";'></div>";
					vlanString += "<span class='vlanListText'>" + vlanInfo.name + "</span>";
				});

				// Append the string to the dialog
				$("#cableDialogVLAN")
					.append(vlanString)
					.css("display", "block");
			}
			// If only end interface declares a VLAN
			else if(count(topologyCables[cableID].end.data("vlan")) > 0) {
				// Process all VLANs at end interface
				$.each(topologyCables[cableID].end.data("vlan"), function(index, vlanInfo) {
					if(parseInt(index, 10) > 0) {
						vlanString += "<span class='vlanListText'>, </span>";
					}

					vlanString += "<div class='vlanListColorBox' style='background-color:" + vlanInfo.color + ";'></div>";
					vlanString += "<span class='vlanListText'>" + vlanInfo.name + "</span>";
				});

				// Append the string to the dialog
				$("#cableDialogVLAN")
					.append(vlanString)
					.css("display", "block");
			}
			else {
				// No VLANs declared, hide VLAN information
				$("#cableDialogVLAN").css("display", "none");
			}

			// Hide the remove cable button if the cable is virtual
			if(cableIsVirtual === true) {
				$("#cableDialogOptionsWidget").css("display", "none");
			}
			else {
				$("#cableDialogOptionsWidget").css("display", "block");
			}

			// Open the dialog
			cableDialog.dialog('open');
		}
	}	//cable_click()


	/**
	 * Propagate events on a dummy to the table cell below
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function cable_event_propagate(e) {
		var gloc;	// Grid location of the event target

		// Get the grid location of the event target
		gloc = calcGridLocation($(e.target));

		// Prevent propagation if event does not happen inside the editor grid
		if(gloc !== null) {
			// Set the event target to the grid cell
			e.target = gloc.obj[0];

			// Propagate the event by triggering it on the grid cell
			gloc.obj.trigger(e);
		}
	}	//cable_event_propagate()


	/**
	 * Handle change event on path finding checkbox
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_pathFinder_change(e) {
		// Get true or false value representing if the checkbox is checked or not
		optPathFinderEnable = $(this).is(':checked');
	}	//opt_pathFinder_change()


	/**
	 * Handle change event on show names checkbox
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_names_change(e) {
		// If the checkbox is checked, show all tooltips and disable qtips to prevent hiding of tooltips
		// Otherwise, reenable qtips and hide all tooltips
		if($(this).is(':checked')) {
			// Request to disable dragging if neccessary
			lockDrag();

			// Make tooltips visible by triggering a mouseover event
			$(".component:not(.clone)").mouseover();

			// Once the tips are shown, disable the qtip function to prevent hiding of the tooltips
			$('.qtip').qtip('disable');
		}
		else {
			// Release the drag lock and reenable dragging if possible
			releaseDrag();

			// Reenable tooltips and hide them
			$('.qtip').qtip('enable').qtip('hide');
		}
	}	//opt_names_change()


	/**
	 * Handle change event on show VLAN checkbox
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_vlans_change(e) {
		var optCheckBox = $(this).is(':checked');	// Value of the checkbox

		// Iterate through all ports which are attached to a VLAN
		$(".vlan").each(function(index, obj) {
			var cableID;	// ID of the cable connected to the port

			// Check if the checkbox is checked or not
			if(optCheckBox) {
				// If a cable is connected to this port, add the CSS class of the VLAN to it
				if(count($(obj).data("vlan")) > 0 && calcGridLocation($(obj)).obj.attr("class").match(/\b(ncable(_virtual)?_\d+)\b/)) {
					cableID = RegExp.$1;
					// TODO handle multiple VLANs, current only VLAN 0 is used
					topologyCables[cableID].path.not(".cableCrossImg").addClass($(obj).data("vlan")[0].identifier);
				}
			}
			else {
				// If a cable is connected to this port, remove the CSS class of the VLAN from it
				if(count($(obj).data("vlan")) > 0 && calcGridLocation($(obj)).obj.attr("class").match(/\b(ncable(_virtual)?_\d+)\b/)) {
					cableID = RegExp.$1;
					topologyCables[cableID].path.not(".cableCrossImg").removeClass($(obj).data("vlan")[0].identifier);
				}
			}
		});

		// Check if the checkbox is checked or not
		if(optCheckBox) {
			// Disable drag while VLANs are shown
			// Request to disable dragging if neccessary
			lockDrag();
		}
		else {
			// Release the drag lock and reenable dragging if possible
			releaseDrag();
		}
	}	//opt_vlans_change()


	/**
	 * Handle click event on Configure button to open Topology dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_topoconfigure_click(e) {
		topologyDialog.dialog("open");
	}	//opt_topoconfigure_click()


	/**
	 * Handle click event on VLAN button to open manage VLANs dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_network_click(e) {
		var networkRows = $(),
			vlanRows = $(),
			newRow,
			modifyLinks;

		if(topologyStorage.networks !== undefined && count(topologyStorage.networks) > 0) {
			$.each(topologyStorage.networks, function(networkID, networkInfo) {
				var versionStr;

				newRow = $("<tr class='vlanRow trborder'><td>" + networkInfo.address.address + "</td><td>" + networkInfo.subnetMask + "</td></tr>");

				if(networkInfo.version === "ipv4") {
					versionStr = "IPv4";
				}
				else if(networkInfo.version === "ipv6") {
					versionStr = "IPv6";
				}
				else {
					versionStr = "Unknown";
				}

				newRow.append($("<td>" + versionStr + "</td>"));

				networkRows = networkRows.add(newRow);
			});
		}
		else {
			networkRows = $("<tr class='vlanRow trborder'><td colspan='3'>" + localizeData.dialog.network.existingnetwork.nonetwork + "</td></tr>");
		}

		$("#networkDialogExistingSubnets")
			.find(".vlanRow").remove().end()
			.append(networkRows)

		if(topologyStorage.vlans !== undefined && count(topologyStorage.vlans) > 0) {
			$.each(topologyStorage.vlans, function(vlanID, vlanInfo) {
				newRow = $("<tr class='vlanRow trborder'><td>" + vlanInfo.name + "</td><td>" + vlanInfo.color + "</td><td>" + vlanIfCount[vlanID] + "</td><td class='modifyLinks'></td></tr>");

				modifyLinks = "<a href='#edit' data-visa='" + vlanID + "' data-localize='dialog.network.existingvlan.edit'>" + localizeData.dialog.network.existingvlan.edit + "</a>";
				if(vlanIfCount[vlanID] === 0) {
					modifyLinks += ", <a href='#del' data-visa='" + vlanID + "' data-localize='dialog.network.existingvlan.remove'>" + localizeData.dialog.network.existingvlan.remove + "</a>";
				}
				newRow.find(".modifyLinks").html(modifyLinks);

				vlanRows = vlanRows.add(newRow);
			});
		}
		else {
			vlanRows = $("<tr class='vlanRow trborder'><td colspan='3'>" + localizeData.dialog.network.existingvlan.novlan + "</td><td></td></tr>");
		}

		$("#vlanDialogExistingVLANs")
			.find(".vlanRow").remove().end()
			.append(vlanRows)
			.find("a[href='#edit']").on("click.visaVLAN", vlanrow_edit_click).end()
			.find("a[href='#del']").on("click.visaVLAN", vlanrow_del_click);

		networkDialog.dialog("open");
	}	//opt_network_click()


	/**
	 * Handle click event on IO-Tool button to open IO-Tool dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_iotool_click(e) {
		iotoolDialog.dialog("open");
	}

	/**
	 * Handle click event on RDF/XML button to open RDF dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_rdf_click(e) {
		if(!optExportTopoExported) {
			$("#rdfDialogStatus").removeClass("statusOKText").addClass("statusErrorText").html(localizeData.dialog.rdf.exportbox.status.notexported);
		}
		else if(optExportDownloadLink !== undefined && !optExportDownloadCurrTopo) {
			$("#rdfDialogStatus").removeClass("statusOKText").addClass("statusErrorText").html(localizeData.dialog.rdf.exportbox.status.notuptodate);
		}

		$("#rdfDialogUploadStatus").empty();

		rdfDialog.dialog("open");

		if(!uploaderInit) {
			$("#rdfDialogUploadStatus")
				.fineUploader({
					uploaderType: "basic",
					button: $("#rdfDialogImport"),
					request: {
						endpoint: "upload.php"
					},
					validation: {
						allowedExtensions: ["rdf"],
						acceptFiles: "application/rdf+xml",
						sizeLimit: 10 * 1024 * 1024 // 10MB
					}
				})
				.on("submit.visaImport", function(e, id, fileName){
					$("#rdfDialogUploadStatus").html("File selected: " + fileName + "<br />").css("display", "block");
				})
				.on("upload.visaImport", function(e, id, fileName){
					$("#rdfDialogUploadStatus").append("Uploading file '" + fileName + "'...");
				})
				.on("progress.visaImport", function(e, id, fileName, loaded, total) { })
				.on("error.visaImport", function(e, id, fileName, reason) {
					$("#rdfDialogUploadStatus").html("Invalid file selected: " + fileName + "<br />" + reason).css("display", "block");
				})
				.on("complete.visaImport", uploader_complete);

			uploaderInit = true;
		}
	}	//opt_rdf_click()


	/**
	 * Handle click event on reset backend button to open reset dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_reset_click(e) {
		resetDialog.dialog("open");
	}	//opt_reset_click()


	/**
	 * Handle click event on shutdown backend button to open shutdown dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_shutdown_click(e) {
		var confirmAction = function shutdownDialogDo() {
			// Tell the backend to shutdown itself
			$.ajax({
				url: 'ajax/shutdownBackend',
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					if(response.status === "ajaxException") {
						alert('Exception in backend during topology reset request');
					}
					else if(response.status === "ajaxShutdown"){
						backendDown();
					}
					else {
						alert('Error during shutdown request');
					}
				}
			});
		}

		confirmDialog(localizeData.dialog.confirm.msg.shutdown.title, localizeData.dialog.confirm.msg.shutdown.body, confirmAction);
	}	//opt_shutdown_click()


	/**
	 * Handle change event on language drop down
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_language_change(e) {
		var lang;	// Selected language

		// Get the selected language
		lang = $('#optLanguage option:selected').val();

		// Localize the UI to the set custom language
		$("[data-localize]").localize("visa", {pathPrefix: "i18n", callback: localizeHandler, language: lang});

		// Store the custom language in a cookie
		$.cookie("lang", lang, {expires: 14});
	}	//opt_language_change()


	/**
	 * Handle click event on new VSA button to open add VSA dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function opt_newvsa_click(e) {
		var templateSelect,
			selectOpts = $("<option value='none' selected='selected'>Bitte wählen</option>");

		console.log(vsaTemplates);

		$.each(vsaTemplates, function(index, tpl) {
			selectOpts = selectOpts.add("<option value='" + index + "'>" + tpl.name + "</option>");
		});

		$("#createVSADialogSelect")
			.off(".visaDialog")
			.empty()
			.append(selectOpts)
			.removeAttr("disabled")
			.on("change.visaDialog", tpl_select_change);


		createVSADialog.dialog("open");
	}	//opt_newvsa_click()


	/**
	 * Handle drop events on the editorgrid
	 *
	 * @param {Object} e jQuery event object
	 * @param {Object} ui jQuery UI helper object
	 * @memberOf VISA
	 */
	function drag_editor_accept(e, ui) {
		var offsetEditorGrid,			// Offset (relative to document) of the editorgrid
			dialogOffset = {},
			subgridStr,
			movedPorts,					// Portconnectors which were moved by relocation of an object
			origin;						// New location of the moved object

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
			dialogOffset = $("#" + subgridStr + "dialog").parent().offset();
			dialogOffset.top += 1;
			dialogOffset.left += 1;
		}
		else {
			subgridStr = "";
		}

		// Check if an inventory object was dragged
		if(ui.draggable.hasClass("clone")) {
			createCompDialog
				.data("ui", ui)
				.data("objProps", {
					sizeX: ui.draggable.width() / cellSize,
					sizeY: ui.draggable.height() / cellSize,
					gloc: calcGridLocation(ui.draggable)
				});

			$("#createCompDialogName").val(ui.draggable.attr("title") + " $ID$");
			$("#createCompDialogSizeX").val(ui.draggable.width() / cellSize);
			$("#createCompDialogSizeY").val(ui.draggable.height() / cellSize);
			compsize_apply_click(null);
			createCompDialogIfUpdate(true);

			createCompDialog.dialog("open");
		}
		else {
			// Get the offset of the editorgrid for offset calculations
			offsetEditorGrid = $("#" + subgridStr + "editorgrid").offset();

			// Get the grid location of the helper
			origin = calcGridLocation(ui.helper);

			// Calculate the offset values for the dragbox, that is offset of the grid location + editorgrid offset
			origin.top = origin.y * cellSize + offsetEditorGrid.top - dialogOffset.top;
			origin.left = origin.x * cellSize + offsetEditorGrid.left - dialogOffset.left;

			// Request object relocation from the backend
			$.ajax({
				url: 'ajax/relocateComponent?oid=' + encodeURIComponent(ui.draggable.data("component").attr("id")) + '&glocX=' + encodeURIComponent(origin.x) + '&glocY=' + encodeURIComponent(origin.y),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					if (response.status === "ajaxMissing") {
						// Object relocation failed, reset position of the object
						alert('Missing arguments for relocate component request');
						ui.draggable.offset(ui.draggable.data("origin"));
					}
					else if(response.status === "ajaxException") {
						// Object relocation failed, reset position of the object
						alert('Exception in backend during relocate component request');

						updateTopoStorage(response.topology);

						clearEditor();
						buildTopologyBlock();
						topologyAltered();
					}
					else if(response.status === "ajaxExceptionUnresolved") {
						// Object relocation failed, reset position of the object
						alert('Exception in backend during relocate component request could not be resolved, topology cleared');

						updateTopoStorage(response.topology);

						clearEditor();
						topologyAltered();
					}
					else if(response.status === "ajaxInvalid") {
						// Object relocation failed, reset position of the object
						alert('Invalid object type for relocate component request');
						ui.draggable.offset(ui.draggable.data("origin"));
					}
					else {
						updateTopoStorage(response.topology);

						// Update the stored object location
						ui.draggable.data("origin", origin);

						// Recalculate obstacles
						calcObstacles();

						// Check which ports were moved and redraw cables connected to those
						movedPorts = ui.draggable.data("component").data("portObjs");
						redrawCables(movedPorts);
					}
				}
			});
		}
	}	//drag_editor_accept()


	/**
	 * Handler for the revert option of draggable
	 *
	 * @param {jQuery object} dropObj Droppable if the drop was successful, false if not
	 * @memberOf VISA
	 */
	function drag_revert(dropObj) {
		// Drop failed, any object has to be reverted
		if(dropObj === false) {
			var origin = this.data("origin");	// Original position of the object

			if(origin === undefined) {
				// Inventory object => revert back to top/left = 0px
				this.css("top", "0px").css("left", "0px");
			}
			else {
				// Revert the object back to its original location
				this.offset(origin);
			}
		}
		// Successful drop, only inventory objects need to be reverted
		else {
			if(this.data("origin") === undefined) {
				// Inventory object => revert back to top/left = 0px
				this.css("top", "0px").css("left", "0px");
			}
		}

		// Deactivate the default revert handler, it causes misplacements
		return false;
	}	//drag_revert()


	/**
	 * Handle click event on apply button for component size fields in create component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function compsize_apply_click(e) {
		var objProps,
			newSizeX,
			newSizeY;

		objProps = createCompDialog.data("objProps");

		newSizeX = parseInt($("#createCompDialogSizeX").val(), 10);
		newSizeY = parseInt($("#createCompDialogSizeY").val(), 10);

		if(!$.isNumeric(newSizeX) || newSizeX < 1) {
			newSizeX = 1;
			$("#createCompDialogSizeX").val("1");

		}

		if(!$.isNumeric(newSizeY) || newSizeY < 1) {
			newSizeY = 1;
			$("#createCompDialogSizeY").val("1");
		}

		objProps.sizeX = newSizeX;
		objProps.sizeY = newSizeY;

		ifnum_apply_click(null);
	}	//compsize_apply_click()


	/**
	 * Handle click event on apply button for interface count field in create component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function ifnum_apply_click(e) {
		var num,
			objProps,
			maxIf;

		objProps = createCompDialog.data("objProps");
		maxIf = 2*objProps.sizeX + 2*objProps.sizeY;

		num = parseInt($("#createCompDialogIfnum").val(), 10);

		if(!$.isNumeric(num) || num < 1) {
			$("#createCompDialogIfnum").val("1");
		}
		else if(num > maxIf) {
			$("#createCompDialogIfnum").val(String(maxIf));
		}

		$("#createCompDialogMaxIfnum").html(" (max. " + maxIf + ")");
		createCompDialogIfUpdate(false);
	}	//ifnum_apply_click()


	/**
	 * Handle change events on the interface orientation radio buttons in create component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function ifdetail_change(e) {
		createCompDialogIfUpdate(false);
	}	//ifdetail_change()


	/**
	 * Handle click events on the topology list radio buttons in RDF dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function topo_list_change(e) {
		$("#iotoolDialogIOLoad").removeAttr("disabled");
		$("#iotoolDialogIORemove").removeAttr("disabled");
		$("#iotoolDialogIOReplicate").removeAttr("disabled");
		$("#iotoolDialogIOToolOptions :radio").off(".visaDialog");
	}	//topo_list_change()


	/**
	 * Handle click events on edit links in the existing VLAN list
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function vlanrow_edit_click(e) {
		var vlanID = $(e.target).attr("data-visa"),
			vlanInfo = topologyStorage.vlans[vlanID];

		$("#vlanDialogEditName").val(vlanInfo.name);
		$("#vlanDialogEditColor").val(vlanInfo.color);
		$("#vlanDialogEditLocName").val(vlanID);

		// Hide the new VLAN panel and show the edit VLAN panel
		$("#newVLANpanel").css("display", "none");
		$("#editVLANpanel").css("display", "block");

		// Suppress the default link action
		return false;
	}	//function vlanrow_edit_click()


	/**
	 * Handle click events on remove links in the existing VLAN list
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function vlanrow_del_click(e) {
		// Tell the backend to modify the VLAN
		$.ajax({
			url: 'ajax/removeVLAN?locname=' + encodeURIComponent($(e.target).attr("data-visa")),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for remove VLAN request');
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during remove VLAN request');

					updateTopoStorage(response.topology);

					clearEditor();
					buildTopologyBlock();
					topologyAltered();
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					alert('Exception in backend during remove VLAN request could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();
				}
				else if(response.status === "ajaxSuccess") {
					updateTopoStorage(response.topology);
					topologyAltered();
				}
				else {
					alert("Unknown error during remove VLAN request");
				}
			}
		});

		opt_network_click(null);

		return false;
	}	//vlanrow_del_click()


	/**
	 * Handler for the complete event of the FineUploader
	 *
	 * @param {Object} e jQuery event object
	 * @param {String} id
	 * @param {String} fileName Name of the uploaded file
	 * @param {Object} responseJSON Reponse object of the FineUploader
	 * @memberOf VISA
	 */
	function uploader_complete(e, id, fileName, responseJSON) {
		var replaceValue,
			rebuildTopology;

		if (responseJSON.success) {
			$("#rdfDialogUploadStatus").addClass("statusOKText").append("success!");

			replaceValue = $("input[name=replace]:checked").val();

			$.ajax({
				url: 'ajax/importRDFXML?file=' + encodeURIComponent(responseJSON.remote_file) + "&replace=" + encodeURIComponent(replaceValue),
				type: 'GET',
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for import RDF/XML request');
						rebuildTopology = false;
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during import RDF/XML request');

						updateTopoStorage(response.topology);
						generateStateList();

						rebuildTopology = true;
					}
					else if(response.status === "ajaxExceptionUnresolved") {
						alert('Exception in backend during import RDF/XML request could not be resolved, topology cleared');

						clearEditor();

						rebuildTopology = false;
					}
					else if(response.status === "ajaxGeneral") {
						alert('Error during import RDF/XML request');
						rebuildTopology = false;
					}
					else {
						updateTopoStorage(response.topology);
						generateStateList();

						rebuildTopology = true;
					}
				}
			});

			if(rebuildTopology) {
				if(replaceValue === "true") {
					optExportTopoExported = false;
					optExportDownloadCurrTopo = false;
					$("#rdfDialogStatus").removeClass("statusOKText").addClass("statusErrorText").html(localizeData.dialog.rdf.exportbox.status.notexported);
					$("#rdfDialogDownload").attr("disabled", "disabled");
				}
				else {
					topologyAltered();
				}

				clearEditor();

				// Block the UI to prevent further user actions and build topology
				buildTopologyBlock();
			}
		}
		else {
			$("#rdfDialogUploadStatus").addClass("statusErrorText").append("failure!<br />" + responseJSON.error);
		}
	}	//uploader_complete()


	/**
	 * Handle change events on VSA template selection in create VSA dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function tpl_select_change(e) {
		var obj = $(e.target),
			targetSelect,
			targetSelectOpts = $(),
			vlanSelect,
			vlanSelectOpts = $(),
			tpl,
			propContent = $();

		if(obj.val() === "none") {
			// The "please select" line was selected
			activeVSATemplate = null;
			$("#createVSADialogProperties").empty();
		}
		else if(obj.val() !== activeVSATemplate) {
			// VSA template selected

			// Build the connection target select structure
			targetSelect = $("<select class='input-medium'></select>");

			targetSelectOpts = targetSelectOpts.add("<option value='none'>---</option>");
			$.each(topologyStorage.groups["cgroup0"].components, function(objID, objInfo) {
				targetSelectOpts = targetSelectOpts.add("<option value='" + objID + "' data-isswitch='" + objInfo.isSwitch + "'>" + objInfo.name + "</option>");
			});
			targetSelect.append(targetSelectOpts);

			// Build the connection target vlan select structure
			vlanSelect = $("<select class='input-medium'></select>");

			vlanSelectOpts = vlanSelectOpts.add("<option value='none'>---</option>");
			if(topologyStorage.vlans !== undefined && topologyStorage.vlans !== null) {
				$.each(topologyStorage.vlans, function(vlanID, vlanInfo) {
					vlanSelectOpts = vlanSelectOpts.add("<option value='" + vlanID + "'>" + vlanInfo.name + "</option>");
				});
			}
			vlanSelect.append(vlanSelectOpts);

			// Get the template properties
			activeVSATemplate = vsaTemplates[obj.val()];

			// Build the property box content
			propContent = propContent.add("<label for='createVSADialogName'>" + localizeData.dialog.createvsa.propertybox.name + "</label><input id='createVSADialogName' type='text' name='compname' />");
			propContent = propContent.add("<p class='dialogHeadline' data-localize='dialog.createvsa.propertybox.connections'>" + localizeData.dialog.createvsa.propertybox.connections + "</p>");

			// Add content for connections
			$.each(activeVSATemplate.connections, function(connID, conn) {
				propContent = propContent.add("<p>" + conn.description + "</p>");
				propContent = propContent.add("<label for='" + connID + "'>" + localizeData.dialog.createvsa.propertybox.target + "</label>");
				propContent = propContent.add(targetSelect.clone().attr("id", connID).on("change.visaDialog", tpl_target_change));
				propContent = propContent.add(vlanSelect.clone().attr("id", connID + "_vlan").css("visibility", "hidden"));
			});

			// Clear the property box and append the created content
			$("#createVSADialogProperties")
				.empty()
				.append(propContent);
		}
	}	//tpl_select_change()


	/**
	 * Handle change events on VSA template connection target selection in create VSA dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function tpl_target_change(e) {
		var obj = $(e.target);

		if(obj.val() === "none" && obj.data("previous") !== undefined) {
			// Do not allow selection of the "none" entry, select the previously selected item if existent
			obj
				.find("option").removeAttr("selected").end()
				.find("option[value='" + obj.data("previous") + "']").attr("selected", "selected");
		}
		else {
			// Store the selected value als previously selected item (queried at the next change event)
			obj.data("previous", obj.val());

			if(obj.find("option[value='" + obj.val() + "']").attr("data-isswitch") === "true") {
				// If the selected target is a switch, allow VLAN selection
				$("#" + obj.attr("id") + "_vlan").css("visibility", "visible");
			}
			else {
				// If the selected target is not a switch, hide and reset VLAN selection
				$("#" + obj.attr("id") + "_vlan")
					.css("visibility", "hidden")
					.find("option").removeAttr("selected").end()
					.find("option[value='none']").attr("selected", "selected");
			}
		}
	}	//tpl_target_change()


	/**
	 * Callback for the remove option on component context menus
	 *
	 * @param {String} key The key of the clicked option
	 * @param {Object} opt Runtime options object of jQuery.contextMenu
	 * @memberOf VISA
	 */
	function menu_cb_removeComponent(key, opt) {
		var confirmAction = function() {
			$.ajax({
				url: 'ajax/removeComponent?oid=' + encodeURIComponent(opt.$trigger.attr("id")),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html),
						dragbox = $("#" + opt.$trigger.attr("id") + "_box");

					if (response.status === "ajaxMissing") {
						// Object removal failed, reset position of the object
						alert('Missing arguments for remove component request');
					}
					else if(response.status === "ajaxException") {
						// Object removal failed, reset position of the object
						alert('Exception in backend during remove component request');

						updateTopoStorage(response.topology);

						clearEditor();
						buildTopologyBlock();
						topologyAltered();
					}
					else if(response.status === "ajaxExceptionUnresolved") {
						// Object relocation failed, reset position of the object
						alert('Exception in backend during relocate component request could not be resolved, topology cleared');

						clearEditor();
						topologyAltered();
					}
					else if(response.status === "ajaxGeneral") {
						// Object removal failed, reset position of the object
						alert('Error during remove component request');
					}
					else {
						updateTopoStorage(response.topology);

						removeObject(dragbox);
						topologyAltered();
					}
				}
			});
		};

		confirmDialog(localizeData.dialog.confirm.msg.remcomp.title, localizeData.dialog.confirm.msg.remcomp.body1 + opt.$trigger.attr("title") + localizeData.dialog.confirm.msg.remcomp.body2, confirmAction);
	}	//menu_cb_removeComponent()


	/**
	 * Callback for the remove option on component context menus
	 *
	 * @param {String} key The key of the clicked option
	 * @param {Object} opt Runtime options object of jQuery.contextMenu
	 * @memberOf VISA
	 */
	function menu_cb_configureComponent(key, opt) {
		var objInfo;

		if(activeSubgrid !== null) {
			objInfo = topologyStorage.groups[activeSubgrid].components[opt.$trigger.attr("id")];
		}
		else {
			objInfo = topologyStorage.groups["cgroup0"].components[opt.$trigger.attr("id")];
		}

		buildConfigureComponentDialog(objInfo);
	}	//menu_cb_configureComponent()


	/**
	 * TODO JSDoc
	 *
	 */
	function buildConfigureComponentDialog(objInfo) {
		var compType,
			addIfButton,
			addIfLine,
			ifList = $(),
			vlanButtonDisabled = "",
			oriSelectDisabled = false;

		if(componentDialog.dialog("isOpen") === true) {
			componentDialog.dialog("close");
		}

		if(objInfo.isSwitch === true) {
			compType = localizeData.dialog.comp.identbox.types.switch;
			oriSelectDisabled = true;
		}
		else if(objInfo.isVirtual === true) {
			compType = localizeData.dialog.comp.identbox.types.vm;
			vlanButtonDisabled = " disabled='disabled'";
		}
		else {
			compType = localizeData.dialog.comp.identbox.types.host;
			vlanButtonDisabled = " disabled='disabled'";
		}

		componentDialog
			.find("#componentDialogName").val(objInfo.name).end()
			.find("#componentDialogID").text(objInfo.identifier).end()
			.find("#componentDialogType").text(compType).end();

		addIfButton = $("<div id='componentDialogAddInterface' class='btn btn-small' style='float: left;margin-left: 10px;' data-localize='dialog.comp.ifbox.newinterface'>" + localizeData.dialog.comp.ifbox.newinterface + "</div>")
			.on("click.visaDialog", addInterface_click);

		addIfLine = $(
			"<div class='ui-widget-header dialogWidgetHeader dialogSubWidgetHead' data-localize='dialog.comp.ifbox.newinterfacetitle'>" + localizeData.dialog.comp.ifbox.newinterfacetitle + "</div>" +
			"<div class='ui-widget-content ui-helper-clearfix dialogWidgetContent' style='padding-top: 3px;'></div>"
		).filter(".dialogWidgetContent")
			.append(ifOrientationSelect.clone().attr("id", "componentDialogAddInterfaceOrientation").css("float", "left"))
			.append(addIfButton)
			.end();

		ifList = ifList.add(addIfLine);

		$.each(objInfo.config.interfaces, function(ifID, ifInfo) {
			var newIfLine,
				ipAddr = "",
				linkLocal = "",
				lineOriSelect,
				lineNetworkSelect,
				vlanString = "",
				vlanListTR;

			lineOriSelect = ifOrientationSelect.clone().attr("data-visa", ifInfo.identifier).on("change.visaDialog", oriSelect_change).find("option[value='" + ifInfo.orientation + "']").attr("selected", "selected").end();
			if(oriSelectDisabled === true) {
				lineOriSelect.attr("disabled", "disabled");
			}

			lineNetworkSelect = networkSelect.clone().attr("data-visa", ifInfo.identifier).on("change.visaDialog", networkSelect_change);

			$.each(ifInfo.ipconf, function(id, ipConf) {
				if(ipConf.isLinkLocal === true) {
					if(linkLocal.length > 0) {
						linkLocal += ", ";
					}
					linkLocal += ipConf.address;
				}
				else {
					if(ipAddr.length > 0) {
						ipAddr += ", ";
					}
					ipAddr += ipConf.address;

					lineNetworkSelect
						.find("option").removeAttr("selected").end()
						.find("option[value='" + ipConf.network.address.address + "']").attr("selected", "selected");
				}
			});

			if(ipAddr.length === 0) {
				ipAddr = "---";
			}
			if(linkLocal.length === 0) {
				linkLocal = "---";
			}

			newIfLine = $(
					"<div class='ui-widget-header dialogWidgetHeader dialogSubWidgetHead'>" + ifInfo.identifier + "</div>" +
					"<div class='ui-widget-content dialogWidgetContent'>" +
						"<table>" +
							"<tbody>" +
								"<tr>" +
									"<th style='width: 90px;' data-localize='dialog.comp.ifbox.ipaddress'>" + localizeData.dialog.comp.ifbox.ipaddress + "</th>" +
									"<td style='width: 170px;'>" + ipAddr + "</td>" +
									"<th style='width: 90px;' data-localize='dialog.comp.ifbox.linklocal'>" + localizeData.dialog.comp.ifbox.linklocal + "</th>" +
									"<td>" + linkLocal + "</td>" +
									"<td>&nbsp;</td>" +
								"</tr>" +
								"<tr>" +
									"<th style='width: 90px;' data-localize='dialog.comp.ifbox.network'>" + localizeData.dialog.comp.ifbox.network + "</th>" +
									"<td class='networkSelect' style='width: 170px;'></td>" +
									"<th style='width: 90px;' data-localize='dialog.comp.ifbox.orientation'>" + localizeData.dialog.comp.ifbox.orientation + "</th>" +
									"<td class='oriSelect'></td>" +
									"<td>&nbsp;</td>" +
								"</tr>" +
							"</tbody>" +
						"</table>" +
					"</div>"
				)
				.find(".oriSelect").html(lineOriSelect).end()
				.find(".networkSelect").html(lineNetworkSelect).end();

			if(objInfo.isSwitch === true) {
				if(ifInfo.vlan !== undefined && ifInfo.vlan !== null) {
					$.each(ifInfo.vlan, function(index, vlanInfo) {
						if(parseInt(index, 10) > 0) {
							vlanString += "<span class='vlanListText'>, </span>";
						}

						vlanString += "<div class='vlanListColorBox' style='background-color:" + vlanInfo.color + ";'></div>";
						vlanString += "<span class='vlanListText'>" + vlanInfo.name + "</span>";
					});
				}

				vlanListTR = $(
						"<tr>" +
							"<th data-localize='dialog.comp.ifbox.vlan'>" + localizeData.dialog.comp.ifbox.vlan + "</th>" +
							"<td colspan='3' class='ui-helper-clearfix' data-visa='" + ifInfo.identifier + "'>" + vlanString + "</td>" +
							"<td style='text-align: right;'>" +
								"<div class='btn btn-small' data-localize='dialog.comp.ifbox.vlanedit'" + vlanButtonDisabled + ">" + localizeData.dialog.comp.ifbox.vlanedit + "</div>" +
							"</td>" +
						"</tr>"
					)
					.find("div.btn")
						.data("component", objInfo)
						.data("interface", ifInfo)
						.on("click.visaDialog", vlanAssign_click).end();

				newIfLine.find("tbody").append(vlanListTR);
			}

			ifList = ifList.add(newIfLine);
		});
		$("#componentDialogIfList").html(ifList);

		componentDialog.dialog("open");
	}


	/**
	 * Handle change events on network select elements in configure component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function networkSelect_change(e) {
		var obj = $(e.target);

		// Queue network change modification
		$.ajax({
			url: 'ajax/queuedModifyInterfaceIP?queueID=' + encodeURIComponent($("#componentDialogID").text()) + '&ifID=' + encodeURIComponent(obj.attr("data-visa"))  + '&net=' + encodeURIComponent(obj.val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during queue interface network modification request');
					rebuildTopology = false;
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for queue interface network modification request');
					rebuildTopology = false;
				}
				else if(response.status !== "ajaxSuccess") {
					alert('Unknown error during queue interface network modification request');
				}
			}
		});
	}	//networkSelect_change()


	/**
	 * Handle change events on orientation select elements in configure component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function oriSelect_change(e) {
		var obj = $(e.target);

		// Queue orientation change modification
		$.ajax({
			url: 'ajax/queuedModifyInterfaceOri?queueID=' + encodeURIComponent($("#componentDialogID").text()) + '&ifID=' + encodeURIComponent(obj.attr("data-visa"))  + '&ori=' + encodeURIComponent(obj.val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during queue interface orientation modification request');
					rebuildTopology = false;
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for queue interface orientation modification request');
					rebuildTopology = false;
				}
				else if(response.status !== "ajaxSuccess") {
					alert('Unknown error during queue interface orientation modification request');
				}
			}
		});
	}	//oriSelect_change()


	/**
	 * Handle click events on add interface button in configure component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function addInterface_click(e) {
		$.ajax({
			url: 'ajax/addInterfaceToComp?compID=' + encodeURIComponent($("#componentDialogID").text()) + '&ori=' + encodeURIComponent($("#componentDialogAddInterfaceOrientation").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html),
					objInfo,
					vlanButtonDisabled,
					oriSelectDisabled,
					ifInfo,
					lineOriSelect,
					lineNetworkSelect,
					ipAddr,
					linkLocal,
					newIfLine;

				if (response.status === "ajaxMissing") {
					// Object removal failed, reset position of the object
					alert('Missing arguments for add interface request');
				}
				else if(response.status === "ajaxException") {
					// Object removal failed, reset position of the object
					alert('Exception in backend during add interface request');
				}
				else if(response.status === "ajaxGeneral") {
					// Object removal failed, reset position of the object
					alert('Error during add interface request');
				}
				else if(response.status === "ajaxSuccess") {
					componentDialog.addClass("interfaceAdded");
					updateTopoStorage(response.topology);

					if(activeSubgrid !== null) {
						objInfo = topologyStorage.groups[activeSubgrid].components[$("#componentDialogID").text()];
					}
					else {
						objInfo = topologyStorage.groups["cgroup0"].components[$("#componentDialogID").text()];
					}

					if(objInfo.isSwitch === false) {
						vlanButtonDisabled = " disabled='disabled'";
					}
					else {
						vlanButtonDisabled = "";
						oriSelectDisabled = true;
					}

					ifInfo = response.iface;

					lineOriSelect = ifOrientationSelect.clone().attr("data-visa", ifInfo.identifier).on("change.visaDialog", oriSelect_change).find("option[value='" + ifInfo.orientation + "']").attr("selected", "selected").end();
					if(oriSelectDisabled === true) {
						lineOriSelect.attr("disabled", "disabled");
					}

					lineNetworkSelect = networkSelect.clone().attr("data-visa", ifInfo.identifier).on("change.visaDialog", networkSelect_change);

					ipAddr = "---";
					linkLocal = "---";

					newIfLine = $(
						"<div class='ui-widget-header dialogWidgetHeader dialogSubWidgetHead'>" + ifInfo.identifier + "</div>" +
						"<div class='ui-widget-content dialogWidgetContent'>" +
							"<table>" +
								"<tbody>" +
									"<tr>" +
										"<th style='width: 90px;' data-localize='dialog.comp.ifbox.ipaddress'>" + localizeData.dialog.comp.ifbox.ipaddress + "</th>" +
										"<td style='width: 170px;'>" + ipAddr + "</td>" +
										"<th style='width: 90px;' data-localize='dialog.comp.ifbox.linklocal'>" + localizeData.dialog.comp.ifbox.linklocal + "</th>" +
										"<td>" + linkLocal + "</td>" +
										"<td>&nbsp;</td>" +
									"</tr>" +
									"<tr>" +
										"<th style='width: 90px;' data-localize='dialog.comp.ifbox.network'>" + localizeData.dialog.comp.ifbox.network + "</th>" +
										"<td class='networkSelect' style='width: 170px;'></td>" +
										"<th style='width: 90px;' data-localize='dialog.comp.ifbox.orientation'>" + localizeData.dialog.comp.ifbox.orientation + "</th>" +
										"<td class='oriSelect'></td>" +
										"<td>&nbsp;</td>" +
									"</tr>" +
									"<tr>" +
										"<th data-localize='dialog.comp.ifbox.vlan'>" + localizeData.dialog.comp.ifbox.vlan + "</th>" +
										"<td colspan='3'>" + "</td>" +
										"<td style='text-align: right;'>" +
											"<div class='btn btn-small' data-localize='dialog.comp.ifbox.vlanedit'" + vlanButtonDisabled + ">" + localizeData.dialog.comp.ifbox.vlanedit + "</div>" +
										"</td>" +
									"</tr>" +
								"</tbody>" +
							"</table>" +
						"</div>"
					)
					.find(".oriSelect").html(lineOriSelect).end()
					.find(".networkSelect").html(lineNetworkSelect).end();

					$("#componentDialogIfList").append(newIfLine);
				}
				else {
					alert("Unknown error during add interface request");
				}
			}	//success
		});	//$.ajax
	}	//addInterface_click()


	/**
	 * Handle click events on edit VLAN assignment button in configure component dialog
	 *
	 * @param {Object} e jQuery event object
	 * @memberOf VISA
	 */
	function vlanAssign_click(e) {
		var target = $(e.target),
			objInfo,
			ifInfo;

		objInfo = target.data("component");
		ifInfo = target.data("interface");

		$("#vlanAssignDialogComponent").text(objInfo.name);
		$("#vlanAssignDialogInterface").text(ifInfo.identifier);
		$("#vlanAssignDialogList").find("input").removeAttr("checked");

		if(ifInfo.vlan !== undefined && ifInfo.vlan !== null) {
			$.each(ifInfo.vlan, function(index, vlanInfo) {
				$("#vlanAssignDialogList").find("input[value='" + vlanInfo.identifier + "']").attr("checked", "checked");
			});
		}

		vlanAssignDialog
			.attr("data-visa", objInfo.identifier)
			.removeData("interface")
			.data("interface", ifInfo)
			.dialog("open");
	}	//vlanAssign_click()


	/**
	 * Create a new cable in the backend and draw it
	 *
	 * @returns {String} New cable ID, null if creation failed
	 * @memberOf VISA
	 */
	function createCable() {
		var pathGET = "",			// GET query string for cable corners
			response,
			cableID,				// ID of the new cable
			cableCreated = false;	// Flag: true, if cable was created successfully

		// Create GET query string with cable corners
		$.each(cableCorners, function(index, value) {
			pathGET += "&path[]=" + encodeURIComponent(value.id);
		});

		// Send a AJAX request to the backend to create the cable
		$.ajax({
			url: 'ajax/createCable?oids=' + encodeURIComponent(cableStart.attr("id")) + '&oide=' + encodeURIComponent(cableEnd.attr("id")) + pathGET,
			type: 'GET',
			cache: false,
			async: false,
			success: function (html) {
				response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for create cable request');
					cableCreated = false;
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during create cable request');
					cableCreated = false;
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					// Object relocation failed, reset position of the object
					alert('Exception in backend during create cable request could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();

					cableCreated = false;
				}
				else if(response.status === "ajaxInvalid") {
					alert('Invalid object for create cable request');
					cableCreated = false;
				}
				else {
					cableID = response.newCable.identifier;

					// Check if we created a new cable or updated an old one
					if(topologyCables[cableID] === undefined) {
						optExportDownloadCurrTopo = false;
					}

					updateTopoStorage(response.topology);

					generateStateList();
					topologyAltered();

					cableCreated = true;
				}
			}
		});

		// If cable creation was successful, draw it
		if(cableCreated) {
			topologyCables[cableID] = {};
			topologyCables[cableID].start = cableStart;
			topologyCables[cableID].end = cableEnd;

			drawCable(cableID);

			return cableID;
		}
		else {
			cableCorners = [];

			return null;
		}
	}	//createCable()


	/**
	 * Draw a cable between two interfaces
	 *
	 * @param {String} cableID ID of the cable
	 * @param {boolean} [isVirtual=false] True if this is a virtual cable connecting a group interface with another interface
	 * @memberOf VISA
	 */
	function drawCable(cableID, isVirtual) {
		var obj,			// Grid cell
			subgridStr,
			elements,		// Collection of all grid cells of this cable
			currCorner,		// Cable corner currently selected by i
			prevCorner,		// Cable corner selected by i-1
			prevX,			// X coordinate of prevCorner
			prevY,			// Y coordinate of prevCorner
			currX,			// X coordinate of currCorner
			currY,			// Y coordinate of currCorner
			xDiff,			// Horizontal coordinate difference between currCorner and prevCorner
			yDiff,			// Vertical coordinate difference between currCorner and prevCorner
			i,				// for-loop counter, cable corner index
			j;				// for-loop counter, cable element index

		if(isVirtual === undefined || isVirtual === null) {
			isVirtual = false;
		}

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
			subgridDialogs[activeSubgrid].data("cables")[cableID] = cableID;
		}
		else {
			subgridStr = "";
		}

		// Define topologyCables storage if this function got called without createCable call
		if(topologyCables[cableID] === undefined) {
			topologyCables[cableID] = {};
			topologyCables[cableID].start = cableStart;
			topologyCables[cableID].end = cableEnd;
		}

		topologyCables[cableID].isVirtual = isVirtual;

		if(!isVirtual) {
			// Cleanup editor grid, remove temporary classes if manual routing is enabled
			if(!optPathFinderEnable) {
				$("#" + subgridStr + "editorgrid").find(".newPath").removeClass("newPath");
				$("#" + subgridStr + "editorgrid").find(".tmpPath").removeClass("tmpPath");
				$("#" + subgridStr + "editorgrid").find(".cableCorner").removeClass("cableCorner");
			}
		}

		// Initialize elements with an empty jQuery object
		elements = $();

		// Iterate over all cable corners
		for(i=1; i<cableCorners.length; i++) {
			// Set previous and current corner
			prevCorner = $(cableCorners[i-1]);
			currCorner = $(cableCorners[i]);

			// Image for cable corner is not wanted on the starting port
			if(i !== 1) {
				prevCorner
					.removeClass("cableVerticalImg cableHorizontalImg cableCrossImg cableVerticalImgVirt cableHorizontalImgVirt cableCrossImgVirt")
					.addClass("cable cableCornerImg " + cableID)
					.on("mouseover.visaCable", cable_mouseover)
					.on("mouseout.visaCable", cable_mouseout)
					.on("click.visaCable", cable_click);
			}
			else {
				// Only when i==1 we have to add the previous corner (starting port) to the topologyCables object
				elements = elements.add(prevCorner);
			}

			// The current corner must always be added to the topologyCables object
			elements = elements.add(currCorner);

			// Get the grid coordinates of the previous corner
			prevCorner.attr("id").match(/([a-zA-Z0-9\-]+?_)?c_(\d+)_(\d+)/);
			prevY = parseInt(RegExp.$2, 10);
			prevX = parseInt(RegExp.$3, 10);

			// Get the grid coordinates of the current corner
			currCorner.attr("id").match(/([a-zA-Z0-9\-]+?_)?c_(\d+)_(\d+)/);
			currY = parseInt(RegExp.$2, 10);
			currX = parseInt(RegExp.$3, 10);

			// Calculate differences
			yDiff = prevY - currY;
			xDiff = prevX - currX;

			// Check the direction which we have to follow to draw the cable
			if(yDiff > 0) {
				// Walk upwards
				for(j=prevY; j>=currY; j--) {
					obj = $("#" + subgridStr + "c_" + j + "_" + prevX);
					elements = elements.add(obj);

					// Check if a cable is already present in that location
					if(!obj.hasClass("cable")) {
						// No cable present, draw element of this cable
						obj
							.on("mouseover.visaCable", cable_mouseover)
							.on("mouseout.visaCable", cable_mouseout)
							.on("click.visaCable", cable_click);

						if(isVirtual) {
							obj.addClass("cable cableVirt cableVerticalImgVirt " + cableID);
						}
						else {
							obj.addClass("cable cableVerticalImg " + cableID);
						}
					}
					else if(!obj.hasClass("cableCornerImg") && (obj.hasClass("cableHorizontalImg") || obj.hasClass("cableHorizontalImgVirt"))) {
						// If this location is a cable crossing, remove mouse listeners and change the image
						obj
							.removeClass("cableHorizontalImg cableHorizontalImgVirt")
							.off(".visaCable");

						if(isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirt " + cableID);
						}
						else if(isVirtual) {
							obj.addClass("cableCrossImgVirtVertical " + cableID);
						}
						else if(!isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirtHorizontal " + cableID);
						}
						else {
							obj.addClass("cableCrossImg " + cableID);
						}
					}
				}
			}
			else if(yDiff < 0) {
				// Walk downwards
				for(j=prevY; j<=currY; j++) {
					obj = $("#" + subgridStr + "c_" + j + "_" + prevX);
					elements = elements.add(obj);

					// Check if a cable is already present in that location
					if(!obj.hasClass("cable")) {
						// No cable present, draw element of this cable
						obj
							.on("mouseover.visaCable", cable_mouseover)
							.on("mouseout.visaCable", cable_mouseout)
							.on("click.visaCable", cable_click);

						if(isVirtual) {
							obj.addClass("cable cableVirt cableVerticalImgVirt " + cableID);
						}
						else {
							obj.addClass("cable cableVerticalImg " + cableID);
						}
					}
					else if(!obj.hasClass("cableCornerImg") && (obj.hasClass("cableHorizontalImg") || obj.hasClass("cableHorizontalImgVirt"))) {
						// If this location is a cable crossing, remove mouse listeners and change the image
						obj
							.removeClass("cableHorizontalImg cableHorizontalImgVirt")
							.off(".visaCable");

						if(isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirt " + cableID);
						}
						else if(isVirtual) {
							obj.addClass("cableCrossImgVirtVertical " + cableID);
						}
						else if(!isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirtHorizontal " + cableID);
						}
						else {
							obj.addClass("cableCrossImg " + cableID);
						}
					}
				}
			}
			else if(xDiff > 0) {
				// Walk left
				for(j=prevX; j>=currX; j--) {
					obj = $("#" + subgridStr + "c_" + prevY + "_" + j);
					elements = elements.add(obj);

					// Check if a cable is already present in that location
					if(!obj.hasClass("cable")) {
						// No cable present, draw element of this cable
						obj
							.on("mouseover.visaCable", cable_mouseover)
							.on("mouseout.visaCable", cable_mouseout)
							.on("click.visaCable", cable_click);

						if(isVirtual) {
							obj.addClass("cable cableVirt cableHorizontalImgVirt " + cableID);
						}
						else {
							obj.addClass("cable cableHorizontalImg " + cableID);
						}
					}
					else if(!obj.hasClass("cableCornerImg") && (obj.hasClass("cableVerticalImg") || obj.hasClass("cableVerticalImgVirt"))) {
						// If this location is a cable crossing, remove mouse listeners and change the image
						obj
							.removeClass("cableVerticalImg")
							.off(".visaCable");

						if(isVirtual) {
							obj.addClass("cableCrossImgVirt " + cableID);
						}
						else {
							obj.addClass("cableCrossImg " + cableID);
						}

						if(isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirt " + cableID);
						}
						else if(isVirtual) {
							obj.addClass("cableCrossImgVirtHorizontal " + cableID);
						}
						else if(!isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirtVertical " + cableID);
						}
						else {
							obj.addClass("cableCrossImg " + cableID);
						}
					}
				}
			}
			else if(xDiff < 0) {
				// Walk right
				for(j=prevX; j<=currX; j++) {
					obj = $("#" + subgridStr + "c_" + prevY + "_" + j);
					elements = elements.add(obj);

					// Check if a cable is already present in that location
					if(!obj.hasClass("cable")) {
						// No cable present, draw element of this cable
						obj
							.on("mouseover.visaCable", cable_mouseover)
							.on("mouseout.visaCable", cable_mouseout)
							.on("click.visaCable", cable_click);

						if(isVirtual) {
							obj.addClass("cable cableVirt cableHorizontalImgVirt " + cableID);
						}
						else {
							obj.addClass("cable cableHorizontalImg " + cableID);
						}
					}
					else if(!obj.hasClass("cableCornerImg") && (obj.hasClass("cableVerticalImg") || obj.hasClass("cableVerticalImgVirt"))) {
						// If this location is a cable crossing, remove mouse listeners and change the image
						obj
							.removeClass("cableVerticalImg")
							.off(".visaCable");

						if(isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirt " + cableID);
						}
						else if(isVirtual) {
							obj.addClass("cableCrossImgVirtHorizontal " + cableID);
						}
						else if(!isVirtual && obj.hasClass("cableVirt")) {
							obj.addClass("cableCrossImgVirtVertical " + cableID);
						}
						else {
							obj.addClass("cableCrossImg " + cableID);
						}
					}
				}
			}
		}

		// Store the cable path in topologyCables
		topologyCables[cableID].path = elements;
	}	//drawCable()


	/**
	 * Redraw the cables that were connected to a moved component
	 *
	 * @param {Object} movedPorts Portconnector objects (jQuery objects) of the moved component
	 * @memberOf VISA
	 */
	function redrawCables(movedPorts) {
		// Iterate through all moved port connectors
		movedPorts.each(function(index, portConnObj) {
			var cableID,	// ID of the cable
				success;	// Flag: true, if path was found, false otherwise

			// Check if a cable was connected to this port
			if(cablePortMap[portConnObj.id] !== undefined) {
				cableID = cablePortMap[portConnObj.id];

				// Remove the existing cable drawing and recalculate obstacles
				removeCableDrawing(topologyCables[cableID].path, cableID);
				calcObstacles();

				// Set starting and ending portconnectors
				cableStart = topologyCables[cableID].start;
				cableEnd = topologyCables[cableID].end;

				// Open path to portconnectors
				removePortConnectorObstacles();

				// Calculate the path from cable start to end
				success = findPath(calcGridLocation(cableStart).obj[0], calcGridLocation(cableEnd).obj[0]);

				// Draw the cable if routing was successful
				if(success) {
					drawCable(cableID, topologyCables[cableID].isVirtual);
				}
				else {
					cableStart.on("mousedown", port_mousedown);
					cableEnd.on("mousedown", port_mousedown);
				}

				// Reset starting and ending portconnectors
				cableStart = null;
				cableEnd = null;
			}
		});
	}	//redrawCables()


	/**
	 * Remove the drawing of a cable
	 *
	 * @param {jQuery object} cableParts Collection of the cable DOM elements
	 * @param {String} cableID ID of the cable to be removed
	 * @memberOf VISA
	 */
	function removeCableDrawing(cableParts, cableID) {
		// Iterate through all cells of this cable
		cableParts.each(function(index, part) {
			var crossCableID,		// ID of a crossing cable
				crossCableIsVirt,
				jQpart = $(part),	// jQuery object of the current part
				subgrid,
				x,
				y;

			// Check if the cell is a crossing point of two cables
			if(jQpart.hasClass("cableCrossImg") || jQpart.hasClass("cableCrossImgVirt") || jQpart.hasClass("cableCrossImgVirtHorizontal") || jQpart.hasClass("cableCrossImgVirtVertical")) {
				// Remove the cableCrossImg and cable ID classes
				jQpart.removeClass(cableID + " cableCrossImg cableCrossImgVirt cableCrossImgVirtHorizontal cableCrossImgVirtVertical");

				// Check which crossing cable is present here
				part.className.match(/\b(ncable(_virtual)?_\d+)\b/);
				crossCableID = RegExp.$1;
				crossCableIsVirt = (RegExp.$2 === "_virtual");

				// Get the coordinates of this cell
				part.id.match(/([a-zA-Z0-9_]+-\d+_)?c_(\d+)_(\d+)/);
				subgrid = RegExp.$1;
				y = parseInt(RegExp.$2, 10);
				x = parseInt(RegExp.$3, 10);

				if(subgrid === null || subgrid === undefined) {
					subgrid = "";
				}

				// Check which direction the crossing cable is pointing
				if($("#" + subgrid + "c_" + (y-1) + "_" + x).hasClass(crossCableID) || $("#" + subgrid + "c_" + (y+1) + "_" + x).hasClass(crossCableID)) {
					// Vertical cable
					if(crossCableIsVirt) {
						jQpart.addClass("cableVerticalImgVirt");
					}
					else {
						jQpart.addClass("cableVerticalImg").removeClass("cableVirt");
					}
				}
				else {
					// Horizontal cable
					if(crossCableIsVirt) {
						jQpart.addClass("cableHorizontalImgVirt");
					}
					else {
						jQpart.addClass("cableHorizontalImg").removeClass("cableVirt");
					}
				}

				jQpart
					.on("mouseover.visaCable", cable_mouseover)
					.on("mouseout.visaCable", cable_mouseout)
					.on("click.visaCable", cable_click);
			}
			else {
				// No cable crossing, remove all cable related classes and the handlers added by the cable
				jQpart
					.removeClass(cableID + " cable cableVirt cableVerticalImg cableHorizontalImg cableVerticalImgVirt cableHorizontalImgVirt cableCornerImg cableHighlight")
					.off(".visaCable");
			}
		});
	}	//removeCableDrawing()


	/**
	 * Remove obstacle class from starting and ending portconnectors and the cells next to them
	 *
	 * @memberOf VISA
	 */
	function removePortConnectorObstacles() {
		var gloc,			// Grid location of the port
			subgridStr,
			portOrientation;

		if(activeSubgrid !== null) {
			subgridStr = activeSubgrid + "_";
		}
		else {
			subgridStr = "";
		}

		// Process cableStart
		// Get the coordinates of the port marker
		gloc = calcGridLocation(cableStart);

		// Remove the obstacle class from the port marker cell
		gloc.obj.removeClass("obstacle");

		// Get the orientation of the port from the subtypeStorage structure
		portOrientation = cableStart.data("orientation");
		switch(portOrientation) {
			case "TOP":
				// Port is oriented top, walk one row upwards
				gloc.y--;
				break;
			case "LEFT":
				// Port is oriented left, walk one cell left
				gloc.x--;
				break;
			case "RIGHT":
				// Port is oriented right, walk one cell right
				gloc.x++;
				break;
			case "BOTTOM":
				// Port is oriented bottom, walk one row downwards
				gloc.y++;
				break;
		}

		// Remove the obstacle class from the cell next to the port marker
		$("#" + subgridStr + "c_" + gloc.y + "_" + gloc.x).removeClass("obstacle");


		// Process cableEnd
		// Get the coordinates of the port marker
		gloc = calcGridLocation(cableEnd);

		// Remove the obstacle class from the port marker cell
		gloc.obj.removeClass("obstacle");

		// Get the orientation of the port from the subtypeStorage structure
		portOrientation = cableEnd.data("orientation");
		switch(portOrientation) {
			case "TOP":
				// Port is oriented top, walk one row upwards
				gloc.y--;
				break;
			case "LEFT":
				// Port is oriented left, walk one cell left
				gloc.x--;
				break;
			case "RIGHT":
				// Port is oriented right, walk one cell right
				gloc.x++;
				break;
			case "BOTTOM":
				// Port is oriented bottom, walk one row downwards
				gloc.y++;
				break;
		}

		// Remove the obstacle class from the cell next to the port marker
		$("#" + subgridStr + "c_" + gloc.y + "_" + gloc.x).removeClass("obstacle");
	}	//removePortConnectorObstacles()


	/**
	 * Remove an object from the grid and the topology
	 *
	 * @param {jQuery object} deletedObj Object to be removed
	 * @memberOf VISA
	 */
	function removeObject(deletedObj) {
		// Iterate through all deleted port connectors
		deletedObj.data("component").data("portObjs").each(function(index, portConnObj) {
			var cableID;	// ID of the connected cable

			// Check if a cable was connected to this port
			if(cablePortMap[portConnObj.id] !== undefined) {
				// Get the cable ID
				cableID = cablePortMap[portConnObj.id];

				// Remove the cable
				removeCable(cableID, false);
			}
		});

		// Remove the deleted object from the DOM
		deletedObj.remove();

		// Recalculate obstacles
		calcObstacles();
	}	//removeObject()


	/**
	 * Remove a cable from the grid and the topology
	 *
	 * @param {String} cableID ID of the cable to be removed
	 * @param {Boolean} doAJAXCall true: remove the cable from the backend, false otherwise
	 * @memberOf VISA
	 */
	function removeCable(cableID, doAJAXCall) {
		var doRemoval,	// Flag: true, if AJAX request returned no error
			response,
			start,
			end;

		if(doAJAXCall) {
			// Tell the backend to remove the cable from the topology
			$.ajax({
				url: 'ajax/removeCable?oid=' + encodeURIComponent(cableID),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					response = JSON.parse(html);

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for remove cable request');
						doRemoval = false;
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during remove cable request');
						doRemoval = false;

						updateTopoStorage(response.topology);

						clearEditor();
						buildTopologyBlock();
						topologyAltered();
					}
					else if(response.status === "ajaxExceptionUnresolved") {
						alert('Exception in backend during remove cable request could not be resolved, topology cleared');
						doRemoval = false;

						updateTopoStorage(response.topology);

						clearEditor();
						topologyAltered();
					}
					else if(response.status === "ajaxGeneral") {
						alert('Error during remove cable request');
						doRemoval = false;
					}
					else {
						updateTopoStorage(response.topology);

						optExportDownloadCurrTopo = false;
						doRemoval = true;
					}
				}
			});
		}
		else {
			doRemoval = true;
		}

		if(doRemoval) {
			// Remove the cable drawing
			removeCableDrawing(topologyCables[cableID].path, cableID);

			// Get the port connector IDs of the start and end ports
			start = topologyCables[cableID].start;
			end = topologyCables[cableID].end;

			// Remove stored information about this cable
			delete cablePortMap[start.attr("id")];
			delete cablePortMap[end.attr("id")];
			delete topologyCables[cableID];

			// Reenable mouse listeners on start and end port
			start.on("mousedown.visaPorts", port_mousedown);
			end.on("mousedown.visaPorts", port_mousedown);
		}
	}	//removeCable()


	/**
	 * Update interface details in create component dialog
	 *
	 * @param {Boolean} replace true: Remove old interface details from the dialog, false: keep and restore old details if possible
	 * @memberOf VISA
	 */
	function createCompDialogIfUpdate(replace) {
		var ifBox = $("#createCompDialogIfBox"),
			ifNum,
			objProps,
			oldDetails,
			newDetail,
			details = $(),
			oldChecked,
			i;

		// Get the properties of the object which will be created
		// and set interface count for each side to 0
		objProps = createCompDialog.data("objProps");
		objProps.ifTop = 0;
		objProps.ifBottom = 0;
		objProps.ifLeft = 0;
		objProps.ifRight = 0;

		// If the current interface details shall be preserved save them, otherwise we just use an empty jQuery object
		if(replace === true) {
			oldDetails = $();
		}
		else {
			oldDetails = ifBox.find(".ifdetail");
			oldDetails.find("input").removeAttr("disabled").off(".visaDialog");
		}
		// Remove all interface detail lines from their container
		ifBox.empty();

		// Read how many interfaces the component shall have
		ifNum = parseInt($("#createCompDialogIfnum").val(), 10);

		// Generate a new detail line for every interface
		for(i=1; i<=ifNum; i++) {
			// If preserved details for this interface are available, use them
			if(i <= oldDetails.length) {
				// Get the checked radio button
				oldChecked = $(oldDetails[i-1]).find(":checked");

				// Check which radio button was checked
				switch(oldChecked.attr("value")) {
					case "TOP":
						// Are there less interfaces added than the component is wide?
						if(objProps.ifTop < objProps.sizeX) {
							// One more was added
							objProps.ifTop++;
						}
						else {
							// The interface does not fit at its old location, move it around the component to find a fitting position
							oldChecked.removeAttr("checked");
							if(objProps.ifBottom < objProps.sizeX) {
								$(oldDetails[i-1]).find("input[value='BOTTOM']").attr("checked", "checked");
								objProps.ifBottom++;
							}
							else if(objProps.ifLeft < objProps.sizeY) {
								$(oldDetails[i-1]).find("input[value='LEFT']").attr("checked", "checked");
								objProps.ifLeft++;
							}
							else {
								$(oldDetails[i-1]).find("input[value='RIGHT']").attr("checked", "checked");
								objProps.ifRight++;
							}
						}

						break;
					case "BOTTOM":
						// Are there less interfaces added than the component is wide?
						if(objProps.ifBottom < objProps.sizeX) {
							// One more was added
							objProps.ifBottom++;
						}
						else {
							// The interface does not fit at its old location, move it around the component to find a fitting position
							oldChecked.removeAttr("checked");
							if(objProps.ifTop < objProps.sizeX) {
								$(oldDetails[i-1]).find("input[value='TOP']").attr("checked", "checked");
								objProps.ifTop++;
							}
							else if(objProps.ifLeft < objProps.sizeY) {
								$(oldDetails[i-1]).find("input[value='LEFT']").attr("checked", "checked");
								objProps.ifLeft++;
							}
							else {
								$(oldDetails[i-1]).find("input[value='RIGHT']").attr("checked", "checked");
								objProps.ifRight++;
							}
						}

						break;
					case "LEFT":
						// Are there less interfaces added than the component is high?
						if(objProps.ifLeft < objProps.sizeY) {
							// One more was added
							objProps.ifLeft++;
						}
						else {
							// The interface does not fit at its old location, move it around the component to find a fitting position
							oldChecked.removeAttr("checked");
							if(objProps.ifRight < objProps.sizeY) {
								$(oldDetails[i-1]).find("input[value='RIGHT']").attr("checked", "checked");
								objProps.ifRight++;
							}
							else if(objProps.ifTop < objProps.sizeX) {
								$(oldDetails[i-1]).find("input[value='TOP']").attr("checked", "checked");
								objProps.ifTop++;
							}
							else {
								$(oldDetails[i-1]).find("input[value='BOTTOM']").attr("checked", "checked");
								objProps.ifBottom++;
							}
						}

						break;
					case "RIGHT":
						// Are there less interfaces added than the component is high?
						if(objProps.ifRight < objProps.sizeY) {
							// One more was added
							objProps.ifRight++;
						}
						else {
							// The interface does not fit at its old location, move it around the component to find a fitting position
							oldChecked.removeAttr("checked");
							if(objProps.ifLeft < objProps.sizeY) {
								$(oldDetails[i-1]).find("input[value='LEFT']").attr("checked", "checked");
								objProps.ifLeft++;
							}
							else if(objProps.ifTop < objProps.sizeX) {
								$(oldDetails[i-1]).find("input[value='TOP']").attr("checked", "checked");
								objProps.ifTop++;
							}
							else {
								$(oldDetails[i-1]).find("input[value='BOTTOM']").attr("checked", "checked");
								objProps.ifBottom++;
							}
						}

						break;
				}

				// Add the detail line to the detail list
				details = details.add(oldDetails[i-1]);
			}
			else {
				// No old detail line exists, create a new one
				newDetail = "<tr class='ifdetail'>";
				newDetail += "<td>Interface " + i + ":</td>";
				newDetail += "<td>";
				newDetail += "<input style='margin-left:10px;' id='if" + i + "oritop' type='radio' name='if" + i + "ori' value='TOP' /><label for='if" + i + "oritop'>" + localizeData.dialog.comp.ifbox.orientations.top + "</label>";
				newDetail += "<input style='margin-left:10px;' id='if" + i + "oribottom' type='radio' name='if" + i + "ori' value='BOTTOM' /><label for='if" + i + "oribottom'>" + localizeData.dialog.comp.ifbox.orientations.bottom + "</label>";
				newDetail += "<input style='margin-left:10px;' id='if" + i + "orileft' type='radio' name='if" + i + "ori' value='LEFT' /><label for='if" + i + "orileft'>" + localizeData.dialog.comp.ifbox.orientations.left + "</label>";
				newDetail += "<input style='margin-left:10px;' id='if" + i + "oriright' type='radio' name='if" + i + "ori' value='RIGHT' /><label for='if" + i + "oriright'>" + localizeData.dialog.comp.ifbox.orientations.right + "</label>";
				newDetail += "</td>";
				newDetail += "</tr>";

				newDetail = $(newDetail);

				// Set the initial value for the interface orientation
				if(objProps.ifTop < objProps.sizeX) {
					newDetail.find("input[value='TOP']").attr("checked", "checked");
					objProps.ifTop++;
				}
				else if(objProps.ifBottom < objProps.sizeX) {
					newDetail.find("input[value='BOTTOM']").attr("checked", "checked");
					objProps.ifBottom++;
				}
				else if(objProps.ifLeft < objProps.sizeY) {
					newDetail.find("input[value='LEFT']").attr("checked", "checked");
					objProps.ifLeft++;
				}
				else {
					newDetail.find("input[value='RIGHT']").attr("checked", "checked");
					objProps.ifRight++;
				}

				// Add the detail line to the detail list
				details = details.add(newDetail);
			}
		}

		// Add change listeners to the radio buttons
		details.find("input").on("change.visaDialog", ifdetail_change);

		// Disable radio buttons for a specific orientation if that side is filled with interfaces
		if(objProps.ifTop === objProps.sizeX) {
			details.find("input[value='TOP']").attr("disabled", "disabled");
		}
		if(objProps.ifBottom === objProps.sizeX) {
			details.find("input[value='BOTTOM']").attr("disabled", "disabled");
		}
		if(objProps.ifLeft === objProps.sizeY) {
			details.find("input[value='LEFT']").attr("disabled", "disabled");
		}
		if(objProps.ifRight === objProps.sizeY) {
			details.find("input[value='RIGHT']").attr("disabled", "disabled");
		}

		// Append the detail lines to their container
		ifBox.append(details);
	}	//createCompDialogIfUpdate()


	/**
	 * Button handler: Create button in create component dialog
	 *
	 * @memberOf VISA
	 */
	function createCompDialogOK() {
		var ui,
			objProps,
			ifOrientationString,
			response,					// AJAX response
			newObj,
			groupStr;

		ui = createCompDialog.data("ui");
		objProps = createCompDialog.data("objProps");
		ifOrientationString = "";

		if(activeSubgrid !== null) {
			groupStr = activeSubgrid;
		}
		else {
			groupStr = "cgroup0";
		}

		$("#createCompDialogIfBox").find("input:checked").each(function(index, ifDetail) {
			ifOrientationString += "&ifori[]=" + encodeURIComponent(ifDetail.value);
		});

		// Request object creation from the backend
		$.ajax({
			url: 'ajax/createComponent?oid=' + encodeURIComponent(ui.draggable.attr("id")) + "&name=" + encodeURIComponent($("#createCompDialogName").val()) + "&group=" + encodeURIComponent(groupStr) + "&dimX=" + encodeURIComponent(objProps.sizeX) + "&dimY=" + encodeURIComponent(objProps.sizeY) + "&ifnum=" + encodeURIComponent($("#createCompDialogIfnum").val()) + ifOrientationString,
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					// Object creation failed, no new object will be created
					alert('Missing arguments for create component request');
				}
				else if(response.status === "ajaxException") {
					// Object creation failed, no new object will be created
					alert('Exception in backend during create component request');

					updateTopoStorage(response.topology);

					clearEditor();
					buildTopologyBlock();
					topologyAltered();
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					alert('Exception in backend during create component request could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();
				}
				else {
					updateTopoStorage(response.topology);

					newObj = createComponent(response.newComponent, objProps.gloc, false);

					generateStateList();
				}
			}
		});

		// Only proceed if the objects fits into the grid
		if(newObj === undefined || newObj === null) {
			$.ajax({
				url: 'ajax/removeComponent?oid=' + encodeURIComponent(response.newComponent.identifier),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					response = JSON.parse(html);

					if (response.status === "ajaxMissing") {
						// Object removal failed
						alert('Missing arguments for remove component request');
					}
					else if(response.status === "ajaxException") {
						// Object removal failed
						alert('Exception in backend during remove component request');

						updateTopoStorage(response.topology);

						clearEditor();
						buildTopologyBlock();
						topologyAltered();
					}
					else if(response.status === "ajaxExceptionUnresolved") {
						alert('Exception in backend during remove component request could not be resolved, topology cleared');

						updateTopoStorage(response.topology);

						clearEditor();
						topologyAltered();
					}
					else if(response.status === "ajaxGeneral") {
						// Object removal failed
						alert('Error during remove component request');
					}
					else {
						updateTopoStorage(response.topology);

						removeObject($("#" + response.newComponent.identifier + "_box"));
						topologyAltered();
					}
				}
			});
		}

		createCompDialog
			.removeData("ui")
			.removeData("objProps")
			.dialog("close");
	}	//createCompDialogOK()


	/**
	 * Button handler: Cancel button in create component dialog
	 *
	 * @memberOf VISA
	 */
	function createCompDialogCancel() {
		createCompDialog
			.removeData("ui")
			.removeData("objProps")
			.dialog("close");
	}	//createCompDialogCancel()


	/**
	 * Button handler: OK button in create VSA dialog
	 *
	 * @memberOf VISA
	 */
	function createVSADialogOK() {
		var targetsSet = true,
			connQuery = "";

		if(activeVSATemplate !== null) {
			if($("#createVSADialogName").val().length !== 0) {
				$.each(activeVSATemplate.connections, function(connID, conn) {
					var obj = $("#" + connID);

					if(obj.val() === "none") {
						targetsSet = false;
					}
					else {
						// Add connID=targetID parameter to the query string
						connQuery += "&";
						connQuery += connID;
						connQuery += "=";
						connQuery += encodeURIComponent(obj.val());

						// Add connID_vlan=vlanID parameter to the query if required
						if(obj.find("option[value='" + obj.val() + "']").attr("data-isswitch") === "true" && $("#" + connID + "_vlan").val() !== "none") {
							connQuery += "&";
							connQuery += connID;
							connQuery += "_vlan=";
							connQuery += encodeURIComponent($("#" + connID + "_vlan").val());
						}
					}

					return targetsSet;
				});

				if(targetsSet === true) {
					$.ajax({
						url: 'ajax/createVSA?tplid=' + encodeURIComponent(activeVSATemplate.id) + '&name=' + encodeURIComponent($("#createVSADialogName").val()) + connQuery,
						type: "GET",
						cache: false,
						async: false,
						success: function (html) {
							var response = JSON.parse(html);

							if(response.status === "ajaxSuccess") {
								updateTopoStorage(response.topology);

								clearEditor();
								buildTopologyBlock();
								topologyAltered();
							}
							else if(response.status === "ajaxMissing") {
								alert('Missing arguments for create VSA request');
							}
							else if(response.status === "ajaxException") {
								alert('Exception in backend during create VSA request');

								updateTopoStorage(response.topology);

								clearEditor();
								buildTopologyBlock();
								topologyAltered();
							}
							else if(response.status === "ajaxExceptionUnresolved") {
								alert('Exception in backend during create VSA request could not be resolved, topology cleared');

								updateTopoStorage(response.topology);

								clearEditor();
								topologyAltered();
							}
							else if(response.status === "ajaxGeneral") {
								alert('Error during create VSA request');
							}
							else {
								alert('Unknown error during create VSA request');
							}
						}
					});
				}
				else {
					alertDialog(localizeData.dialog.alert.msg.novsatarget.title, localizeData.dialog.alert.msg.novsatarget.msg, null);
				}
			}
			else {
				alertDialog(localizeData.dialog.alert.msg.novsaname.title, localizeData.dialog.alert.msg.novsaname.msg, null);
			}
		}

		createVSADialog.dialog("close");

		activeVSATemplate = null;
		$("#createVSADialogProperties").empty();
	}	//createVSADialogOK()


	/**
	 * Button handler: Cancel button in create VSA dialog
	 *
	 * @memberOf VISA
	 */
	function createVSADialogCancel() {
		createVSADialog.dialog("close");

		activeVSATemplate = null;
		$("#createVSADialogProperties").empty();
	}	//createVSADialogCancel()


	/**
	 * Button handler: OK button in cable dialog
	 *
	 * @memberOf VISA
	 */
	function cableDialogClose() {
		cableDialog.dialog("close");
	}	//cableDialogClose()


	/**
	 * Button handler: Remove button in cable dialog
	 *
	 * @memberOf VISA
	 */
	function cableDialogRemove() {
		var cableID;	// ID of the cable to be removed

		cableID = $("#cableDialogID").val();
		removeCable(cableID, true);
		calcObstacles();

		cableDialog.dialog("close");
	}	//cableDialogRemove()


	/**
	 * Button handler: OK button in topology dialog
	 *
	 * @memberOf VISA
	 */
	function topologyDialogOK() {
		if($("#topologyDialogName").val() !== $("#topologyDialogOldName").val()) {
			// Tell the backend to change the name of the topology
			$.ajax({
				url: 'ajax/updateTopology?name=' + encodeURIComponent($("#topologyDialogName").val()),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for update topology request');
						$("#topologyDialogName").val($("#topologyDialogOldName").val());
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during update topology request');
						$("#topologyDialogName").val($("#topologyDialogOldName").val());
					}
					else if(response.status === "ajaxSuccess") {
						$("#topologyDialogOldName").val($("#topologyDialogName").val());
					}
					else {
						alert("Unknown error during update topology request");
					}
				}
			});
		}

		topologyDialog.dialog("close");
	}	//topologyDialogOK()


	/**
	 * Button handler: Cancel button in topology dialog
	 *
	 * @memberOf VISA
	 */
	function topologyDialogCancel() {
		topologyDialog.dialog("close");
	}	//topologyDialogCancel()


	function networkDialogCreate() {
		// Tell the backend to create a new VLAN
		$.ajax({
			url: 'ajax/createSubnet?address=' + encodeURIComponent($("#networkDialogNewIP").val()) + '&subnetmask=' + encodeURIComponent($("#networkDialogNewSubnet").val()) + '&version=' + encodeURIComponent($("#networkDialogNewVersion").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for create subnet request');
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during create subnet request');

					updateTopoStorage(response.topology);

					clearEditor();
					buildTopologyBlock();
					topologyAltered();
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					alert('Exception in backend during create subnet request could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();
				}
				else if(response.status === "ajaxGeneral") {
					alert('General error in backend during create subnet request');
				}
				else if(response.status === "ajaxSuccess") {
					updateTopoStorage(response.topology);
					topologyAltered();
				}
				else {
					alert("Unknown error during create subnet request");
				}
			}
		});

		opt_network_click(null);
		$("#networkDialogNewIP").val("");
		$("#networkDialogNewSubnet").val("24");
		$("#networkDialogNewVersion").val("ipv4");
	}	//networkDialogCreate()


	/**
	 * Button handler: Create button in VLAN dialog
	 *
	 * @memberOf VISA
	 */
	function vlanDialogCreate() {
		// Tell the backend to create a new VLAN
		$.ajax({
			url: 'ajax/createVLAN?name=' + encodeURIComponent($("#vlanDialogNewName").val()) + '&color=' + encodeURIComponent($("#vlanDialogNewColor").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for create VLAN request');
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during create VLAN request');

					updateTopoStorage(response.topology);

					clearEditor();
					buildTopologyBlock();
					topologyAltered();
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					alert('Exception in backend during create VLAN request could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();
				}
				else if(response.status === "ajaxSuccess") {
					updateTopoStorage(response.topology);
					topologyAltered();
				}
				else {
					alert("Unknown error during create VLAN request");
				}
			}
		});

		opt_network_click(null);
		$("#vlanDialogNewName").val("");
		$("#vlanDialogNewColor").val("");
	}	//vlanDialogCreate()


	/**
	 * Button handler: Save edit button in VLAN dialog
	 *
	 * @memberOf VISA
	 */
	function vlanDialogSaveEdit() {
		// Tell the backend to modify the VLAN
		$.ajax({
			url: 'ajax/modifyVLAN?locname=' + encodeURIComponent($("#vlanDialogEditLocName").val()) + '&name=' + encodeURIComponent($("#vlanDialogEditName").val()) + '&color=' + encodeURIComponent($("#vlanDialogEditColor").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for modify VLAN request');
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during modify VLAN request');

					updateTopoStorage(response.topology);

					clearEditor();
					buildTopologyBlock();
					topologyAltered();
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					alert('Exception in backend during modify VLAN request could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();
				}
				else if(response.status === "ajaxSuccess") {
					updateTopoStorage(response.topology);
					topologyAltered();
				}
				else {
					alert("Unknown error during modify VLAN request");
				}
			}
		});

		opt_network_click(null);
		vlanDialogCancelEdit();
	}	//vlanDialogSaveEdit()


	/**
	 * Button handler: Cancel edit button in VLAN dialog
	 *
	 * @memberOf VISA
	 */
	function vlanDialogCancelEdit() {
		// Hide the edit VLAN panel and show the new VLAN panel
		$("#newVLANpanel").css("display", "block");
		$("#editVLANpanel").css("display", "none");

		// Clear the input fields
		$("#vlanDialogEditName").val("");
		$("#vlanDialogEditColor").val("");
		$("#vlanDialogEditLocName").val("");
	}	//vlanDialogCancelEdit()


	/**
	 * Button handler: Cancel button in VLAN dialog
	 *
	 * @memberOf VISA
	 */
	function vlanDialogClose() {
		vlanDialogCancelEdit();

		networkDialog.dialog("close");
	}	//vlanDialogClose()


	/**
	 * Button handler: Connect button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogConnect() {
		var reqTopoList = false;

		// Tell the backend to connect to the IO-Tool
		$.ajax({
			url: 'ajax/ioConnect?host=' + encodeURIComponent($("#iotoolDialogHostname").val()) + "&port=" + encodeURIComponent($("#iotoolDialogPort").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for connect to IO-Tool request');
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during connect to IO-Tool request');
				}
				else if(response.status === "ajaxIOBusy") {
					alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
				}
				else {
					reqTopoList = true;
				}
			}
		});

		if(reqTopoList) {
			ioTopoList();
		}
	}	//iotoolDialogConnect()


	/**
	 * Button handler: Close button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogClose() {
		iotoolDialog.dialog("close");
	}


	/**
	 * Button handler: Disconnect button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogDisconnect() {
		// Tell the backend to disconnect from the IO-Tool
		$.ajax({
			url: 'ajax/ioDisconnect',
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during disconnect from IO-Tool request');
				}
				else if(response.status === "ajaxIOBusy") {
					alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
				}
				else {
					$("#iotoolDialogDisconnect").off(".visaDialog");

					$("#iotoolDialogIOToolOptions").css("display", "none").empty();
					$("#iotoolDialogIOToolConnect").css("display", "block");
				}
			}
		});
	}	//iotoolDialogDisconnect()


	/**
	 * Button handler: Load button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogLoad() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			$.ajax({
				url: 'ajax/ioLoadTopo?id=' + encodeURIComponent($("#iotoolDialogIOToolOptions").find(":checked[name='topo']").val()),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for load topology request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during load topology request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during load topology request');
					}
					else if(response.status === "ajaxSuccess") {
						activeIOTopology = $("#iotoolDialogIOToolOptions").find(":checked[name='topo']").val();

						clearEditor();

						updateTopoStorage(response.topology);

						optExportTopoExported = false;
						optExportDownloadCurrTopo = false;
						$("#rdfDialogStatus").removeClass("statusOKText").addClass("statusErrorText").html(localizeData.dialog.rdf.exportbox.status.notexported);
						$("#rdfDialogDownload").attr("disabled", "disabled");

						buildTopologyBlock();
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during load topology request');
					}
				}
			});
		});
	}	//iotoolDialogLoad()


	/**
	 * Button handler: Save button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogSave() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			$.ajax({
				url: 'ajax/ioWriteTopo?id=' + encodeURIComponent(topologyStorage.identifier),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for write topology request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during write topology request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during write topology request');
					}
					else if(response.status === "ajaxSuccess") {
						ioTopoList();

						activeIOTopology = response.topology.identifier;
						$("#iotoolDialogIOToolOptions").find(":checked[value='" + activeIOTopology + "']").attr("checked", "checked");

						clearEditor();

						updateTopoStorage(response.topology);

						optExportDownloadCurrTopo = false;
						$("#rdfDialogStatus").removeClass("statusOKText").addClass("statusErrorText").html(localizeData.dialog.rdf.exportbox.status.notuptodate);

						buildTopologyBlock();
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during write topology request');
					}
				}
			});
		});
	}	//iotoolDialogSave()


	/**
	 * Button handler: Remove button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogRemove() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			$.ajax({
				url: 'ajax/ioDropTopo?id=' + encodeURIComponent(topologyStorage.identifier),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for drop topology request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during drop topology request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during drop topology request');
					}
					else if(response.status === "ajaxSuccess") {
						ioTopoList();

						$("#iotoolDialogIOToolOptions").find(":checked[value='" + activeIOTopology + "']").attr("checked", "checked");
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during drop topology request');
					}
				}
			});
		});
	}	//iotoolDialogRemove()


	/**
	 * Button handler: Collect button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogCollect() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			// TODO ID of the topology to collect
			$.ajax({
				url: 'ajax/ioCollectTopo?id=demo_topology',
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for collect topology request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during collect topology request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during collect topology request');
					}
					else if(response.status === "ajaxSuccess") {
						ioTopoList();

						$("#iotoolDialogIOToolOptions").find(":checked[value='" + activeIOTopology + "']").attr("checked", "checked");
					}
					else if(response.status === "ajaxIOWait") {
						alert("The execution of this command will take some time, please be patient...");
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during collect topology request');
					}
				}
			});
		});
	}	//iotoolDialogCollect()


	/**
	 * Button handler: Replicate button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogReplicate() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			$.ajax({
				url: 'ajax/ioReplicateTopo?id=' + encodeURIComponent(topologyStorage.identifier),
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for collect topology request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during collect topology request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during collect topology request');
					}
					else if(response.status === "ajaxSuccess") {
						ioTopoList();

						$("#iotoolDialogIOToolOptions").find(":checked[value='" + activeIOTopology + "']").attr("checked", "checked");
					}
					else if(response.status === "ajaxIOWait") {
						alert("The execution of this command will take some time, please be patient...");
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during collect topology request');
					}
				}
			});
		});
	}	//iotoolDialogReplicate()


	/**
	 * Button handler: Clean up button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogCleanup() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			$.ajax({
				url: 'ajax/ioCleanup',
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for clean up IO-Tool request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during clean up IO-Tool request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during clean up IO-Tool request');
					}
					else if(response.status === "ajaxSuccess") {
						ioTopoList();

						$("#iotoolDialogIOToolOptions").find(":checked[value='" + activeIOTopology + "']").attr("checked", "checked");
					}
					else if(response.status === "ajaxIOWait") {
						alert("The execution of this command will take some time, please be patient...");
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during clean up IO-Tool request');
					}
				}
			});
		});
	}	//iotoolDialogCleanup()


	/**
	 * Button handler: Reset button in IO-Tool dialog
	 *
	 * @memberOf VISA
	 */
	function iotoolDialogReset() {
		// Block UI and execute the query
		blockUI_iotool(function() {
			$.ajax({
				url: 'ajax/ioReset',
				type: "GET",
				cache: false,
				async: false,
				success: function (html) {
					var response = JSON.parse(html);

					$.unblockUI();

					if (response.status === "ajaxMissing") {
						alert('Missing arguments for reset IO-Tool request');
					}
					else if(response.status === "ajaxException") {
						alert('Exception in backend during reset IO-Tool request');
					}
					else if(response.status === "ajaxGeneral") {
						alert('General error during reset IO-Tool request');
					}
					else if(response.status === "ajaxSuccess") {
						ioTopoList();

						$("#iotoolDialogIOToolOptions").find(":checked[value='" + activeIOTopology + "']").attr("checked", "checked");
					}
					else if(response.status === "ajaxIOWait") {
						alert("The execution of this command will take some time, please be patient...");
					}
					else if(response.status === "ajaxIOBusy") {
						alertDialog(localizeData.dialog.alert.msg.iotoolbusy.title, localizeData.dialog.alert.msg.iotoolbusy.title, null);
					}
					else {
						alert('Unknown error during reset IO-Tool request');
					}
				}
			});
		});
	}	//iotoolDialogReset()


	/**
	 * Button handler: Export button in RDF dialog
	 *
	 * @memberOf VISA
	 */
	function rdfDialogExport() {
		// Tell the backend to export the current topology as RDF/XML file
		$.ajax({
			url: 'ajax/exportRDFXML?file=' + encodeURIComponent($("#rdfDialogFilename").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if (response.status === "ajaxMissing") {
					alert('Missing arguments for export RDF/XML request');
				}
				else if(response.status === "ajaxException") {
					alert('Exception in backend during export RDF/XML request');
				}
				else if(response.status === "ajaxGeneral") {
					alert('Error during export RDF/XML request');
				}
				else {
					optExportDownloadLink = response.file;
					optExportTopoExported = true;
					optExportDownloadCurrTopo = true;

					// Update status text
					$("#rdfDialogStatus").removeClass("statusErrorText").addClass("statusOKText").html(localizeData.dialog.rdf.exportbox.status.uptodate);
					$("#rdfDialogDownload").removeAttr("disabled").on("click.visaDialog", rdfDialogDownload);
				}
			}
		});
	}	//rdfDialogExport()


	/**
	 * Button handler: Download button in RDF dialog
	 *
	 * @memberOf VISA
	 */
	function rdfDialogDownload() {
		window.open("download.php?exportFile=" + optExportDownloadLink);
	}	//rdfDialogDownload()


	/**
	 * Button handler: Close button in RDF dialog
	 *
	 * @memberOf VISA
	 */
	function rdfDialogClose() {
		rdfDialog.dialog("close");
	}	//rdfDialogClose()


	/**
	 * Button handler: OK button in configure component dialog
	 *
	 * @memberOf VISA
	 */
	function componentDialogOK() {
		// Queue component name change modification
		$.ajax({
			url: 'ajax/queuedModifyComponentName?queueID=' + encodeURIComponent($("#componentDialogID").text()) + '&compID=' + encodeURIComponent($("#componentDialogID").text())  + '&name=' + encodeURIComponent($("#componentDialogName").val()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during queue component name modification request');
					rebuildTopology = false;
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for queue component name modification request');
					rebuildTopology = false;
				}
				else if(response.status !== "ajaxSuccess") {
					alert('Unknown error during queue component name modification request');
				}
			}
		});

		// Execute modification queue
		$.ajax({
			url: 'ajax/executeModificationQueue?queueID=' + encodeURIComponent($("#componentDialogID").text()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during execute modification queue request');
					rebuildTopology = false;
				}
				else if(response.status === "ajaxExceptionUnresolved") {
					alert('Exception in backend during execute modification queue could not be resolved, topology cleared');

					updateTopoStorage(response.topology);

					clearEditor();
					topologyAltered();
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for execute modification queue request');
					rebuildTopology = false;
				}
				else if(response.status === "ajaxSuccess") {
					clearEditor();

					updateTopoStorage(response.topology);

					optExportTopoExported = false;
					optExportDownloadCurrTopo = false;
					$("#rdfDialogStatus").removeClass("statusOKText").addClass("statusErrorText").html(localizeData.dialog.rdf.exportbox.status.notexported);
					$("#rdfDialogDownload").attr("disabled", "disabled");

					buildTopologyBlock();
				}
				else {
					alert('Unknown error during execute modification queue request');
				}
			}
		});

		componentDialog
			.removeClass("interfaceAdded")
			.removeClass("vlanAssigned")
			.dialog("close");
	}	//componentDialogOK()


	/**
	 * Button handler: Cancel button in configure component dialog
	 *
	 * @memberOf VISA
	 */
	function componentDialogCancel() {
		$.ajax({
			url: 'ajax/discardModificationQueue?queueID=' + encodeURIComponent($("#componentDialogID").text()),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during discard modification queue request');
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for discard modification queue request');
				}
				else if(response.status !== "ajaxSuccess") {
					alert('Unknown error during discard modification queue request');
				}
			}
		});

		if(componentDialog.hasClass("interfaceAdded") || componentDialog.hasClass("vlanAssigned")) {
			clearEditor();
			buildTopologyBlock();

			componentDialog
				.removeClass("vlanAssigned")
				.removeClass("interfaceAdded");
		}

		componentDialog.dialog("close");
	}	//componentDialogClose()


	/**
	 * Button handler: Save button in VLAN assignment dialog
	 *
	 * @memberOf VISA
	 */
	function vlanAssignDialogOK() {
		var selectedVLANs,
			vlanQueryStr = "";

		selectedVLANs = $("#vlanAssignDialogList").find("input:checked");

		selectedVLANs.each(function(index, vlanInput) {
			vlanQueryStr += "&vlan[]=";
			vlanQueryStr += encodeURIComponent($(vlanInput).val());
		});

		$.ajax({
			url: 'ajax/modifyVLANAssignment?ifID=' + encodeURIComponent(vlanAssignDialog.data("interface").identifier) + vlanQueryStr,
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html),
					objInfo;

				if(response.status === "ajaxException") {
					alert('Exception in backend during modify VLAN assignment request');
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for modify VLAN assignment request');
				}
				else if(response.status === "ajaxSuccess") {
					updateTopoStorage(response.topology);

					// TODO Update VLAN display
					if(activeSubgrid !== null) {
						objInfo = topologyStorage.groups[activeSubgrid].components[vlanAssignDialog.attr("data-visa")];
					}
					else {
						objInfo = topologyStorage.groups["cgroup0"].components[vlanAssignDialog.attr("data-visa")];
					}

					buildConfigureComponentDialog(objInfo);
				}
				else {
					alert('Unknown error during modify VLAN assignment request');
				}
			}
		});

		componentDialog.addClass("vlanAssigned");
		vlanAssignDialog.dialog("close");
	}	//vlanAssignDialogOK()


	/**
	 * Button handler: Cancel button in VLAN assignment dialog
	 *
	 * @memberOf VISA
	 */
	function vlanAssignDialogCancel() {
		vlanAssignDialog.dialog("close");
	}	//vlanAssignDialogCancel()


	/**
	 * Button handler: OK button in reset dialog
	 *
	 * @memberOf VISA
	 */
	function resetDialogDo() {
		var resetValue,
			mode,
			rebuildTopology;

		resetValue = $("input[name=reset]:checked").val();
		if(resetValue === "-1") {
			mode = "clear";
		}
		else {
			mode = "restore";
		}

		resetDialog.dialog("close");

		// Tell the backend to reset the RDF model and topology
		$.ajax({
			url: 'ajax/resetBackend?mode=' + encodeURIComponent(mode) + '&state=' + encodeURIComponent(resetValue),
			type: "GET",
			cache: false,
			async: false,
			success: function (html) {
				var response = JSON.parse(html);

				if(response.status === "ajaxException") {
					alert('Exception in backend during topology reset request');
					rebuildTopology = false;
				}
				else if(response.status === "ajaxMissing") {
					alert('Missing arguments for topology reset request');
					rebuildTopology = false;
				}
				else {
					updateTopoStorage(response.topology);

					generateStateList();

					rebuildTopology = true;
				}
			}
		});

		if(rebuildTopology) {
			clearEditor();

			buildTopologyBlock();
		}
	}	//resetDialogDo()


	/**
	 * Button handler: Cancel button in reset dialog
	 *
	 * @memberOf VISA
	 */
	function resetDialogClose() {
		resetDialog.dialog("close");
	}	//resetDialogClose()


	/**
	 * Button handler: Close button in group dialog
	 *
	 * @memberOf VISA
	 */
	function groupDialogClose() {
		// This points to the active dialog
		$(this).dialog("close");
	}	//groupDialogClose()


	/**
	 * Shorten names to 5 characters and append "..." if provided string is longer than 5 characters
	 *
	 * @param {String} name Name to be shortened
	 * @returns {String} The shortened name, unchanged if name was shorter than 5 characters
	 * @memberOf VISA
	 */
	function shortenNames(name) {
		if(name.length > 5) {
			return name.substring(0, 5) + "...";
		}
		else {
			return name;
		}
	}	//shortenNames()


	/**
	 * Custom handler function for the jQuery localize plugin
	 *
	 * @param {Object} locData Localization data object
	 * @param {function} defaultHandler Default localization handler of jquery.localize
	 * @memberOf VISA
	 */
	function localizeHandler(locData, defaultHandler) {
		var labelID,	// ID of the label to be localized
			dialog;		// Currently selected dialog

		localizeData = locData;

		ifOrientationSelect
			.find("option[value='TOP']").text(localizeData.dialog.comp.ifbox.orientations.top).end()
			.find("option[value='BOTTOM']").text(localizeData.dialog.comp.ifbox.orientations.bottom).end()
			.find("option[value='LEFT']").text(localizeData.dialog.comp.ifbox.orientations.left).end()
			.find("option[value='RIGHT']").text(localizeData.dialog.comp.ifbox.orientations.right);

		// Localize dialog titles and buttons. jQuery UI dialog plugin creates a complicated DIV structure,
		// so we need this parent-child-what-ever-structure to get the labels in the dialog
		// Create component dialog
		dialog = createCompDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.topology.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").each(function(index, label) {
			// Which button do we localize? Hard to tell, we use the index for identification (DIRTY!)
			if(index === 0) {
				$(label).html(locData.dialog.createcomp.buttons.create);
			}
			else if(index === 1) {
				$(label).html(locData.dialog.createcomp.buttons.cancel);
			}
		});

		// Cable dialog
		dialog = cableDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.cable.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").html(locData.dialog.cable.buttons.close);

		// Configure topology dialog
		dialog = topologyDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.topology.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").each(function(index, label) {
			// Which button do we localize? Hard to tell, we use the index for identification (DIRTY!)
			if(index === 0) {
				$(label).html(locData.dialog.topology.buttons.ok);
			}
			else if(index === 1) {
				$(label).html(locData.dialog.topology.buttons.cancel);
			}
		});

		// Manage VLANs dialog
		dialog = networkDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.network.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").html(locData.dialog.network.buttons.close);

		// Export RDF/XML dialog
		dialog = rdfDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.rdf.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").html(locData.dialog.rdf.buttons.close);

		// Configure component dialog
		dialog = componentDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.comp.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").each(function(index, label) {
			// Which button do we localize? Hard to tell, we use the index for identification (DIRTY!)
			if(index === 0) {
				$(label).html(locData.dialog.comp.buttons.ok);
			}
			else if(index === 1) {
				$(label).html(locData.dialog.comp.buttons.cancel);
			}
		});

		// Reset topology dialog
		dialog = resetDialog.parent();
		labelID = dialog.attr("aria-labelledby");
		$("#" + labelID).html(locData.dialog.reset.title);
		dialog.find(".ui-dialog-buttonset .ui-button-text").each(function(index, label) {
			// Which button do we localize? Hard to tell, we use the index for identification (DIRTY!)
			if(index === 0) {
				$(label).html(locData.dialog.reset.buttons.ok);
			}
			else if(index === 1) {
				$(label).html(locData.dialog.reset.buttons.cancel);
			}
		});

		// Localize the export dialog status text
		if(optExportTopoExported) {
			if(optExportDownloadCurrTopo) {
				$("#rdfDialogStatus").html(locData.dialog.rdf.exportbox.status.uptodate);
			}
			else {
				$("#rdfDialogStatus").html(locData.dialog.rdf.exportbox.status.notuptodate);
			}
		}
		else {
			$("#rdfDialogStatus").html(locData.dialog.rdf.exportbox.status.notexported);
		}

		// Localize tab headers
		$("#tabheaders li").each(function(index, obj) {
			var textID,
				tabID;

			// Get the ID of the A element and the name of the tab
			textID = $(obj).attr("aria-labelledby");
			tabID = $(obj).attr("aria-controls");

			// Localize the tab header
			$("#" + textID).html(locData.components[tabID]);
		});

		defaultHandler(locData);
	}	//localizeHandler()


	/**
	 * Wrapper for PathFinder.line.MikamiTabuchi.findPath()
	 *
	 * @param {DOM object} start starting location (TD DOM element)
	 * @param {DOM object} end ending location (TD DOM element)
	 * @returns {Boolean} true, if routing was successful, false otherwise
	 * @memberOf VISA
	 */
	function findPath(start, end) {
		var success,	// Flag: true, if path was found, false otherwise
			gridID;

		if(activeSubgrid !== null) {
			gridID = activeSubgrid + "_editorgrid";
		}
		else {
			gridID = "editorgrid";
		}

		// Initialize Mikami-Tabuchi PathFinder with the required grid
		PathFinder.line.MikamiTabuchi.init(document.getElementById(gridID));

		success = PathFinder.line.MikamiTabuchi.findPath(start, end);

		if(success) {
			cableCorners = PathFinder.line.MikamiTabuchi.pathCorners;
		}
		PathFinder.line.MikamiTabuchi.reset();

		return success;
	}	//findPath()


	/**
	 * Encode special characters to their HTML representation
	 *
	 * @param {String} value The string to encode
	 * @returns {String} The string with encoded characters
	 * @memberOf VISA
	 */
	function htmlEncode(value) {
		return $('<div/>').text(value).html();
	}	//htmlEncode()


	/**
	 * Decode special characters from their HTML representation
	 *
	 * @param {String} value The string to decode
	 * @returns {String} The decoded string
	 * @memberOf VISA
	 */
	function htmlDecode(value) {
		return $('<div/>').html(value).text();
	}	//htmlDecode()


	/**
	 * Count the number of fields in an object
	 * Source: http://stackoverflow.com/questions/1074365/how-do-i-get-number-of-fields-in-javascript-object
	 *
	 * @param obj {Object} Object whose fields shall be counted
	 * @memberOf VISA
	 */
	function count(obj) {
		if(obj !== undefined && obj !== null) {
			// Old Firefox style
			if (obj.__count__ !== undefined) {
				return obj.__count__;
			}

			// ECMAScript 5 style
			if (Object.keys) {
				return Object.keys(obj).length;
			}

			// Fallback for all other cases (slow)
			var c = 0, p;
			for (p in obj) {
				if (obj.hasOwnProperty(p)) {
					c += 1;
				}
			}
			return c;
		}
		else {
			return 0;
		}
	}	//count()

	return {
		// Public functions
		init : init,
		initView : initView,
		backendDown : backendDown,

		// Puclic attributes
		documentRoot : documentRoot
	};
})();



/*
 * Assign the initialization of the VISA script and GUI components to the jQuery ready function
 */
$(document).ready(function() {
	/* Enable strict mode */
	"use strict";

	$(document).ajaxError(VISA.backendDown);

	// Initialize the VISA script components
	VISA.init(73, 189, 10, 2);

	// Initialize the VISA frontend view
	VISA.initView();
});
